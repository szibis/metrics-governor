<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>metrics-governor Configuration Helper</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>
  <style>
    :root { --status-green: #2ecc40; --status-yellow: #ffdc00; --status-red: #ff4136; }
    .status-green { color: var(--status-green); } .status-yellow { color: var(--status-yellow); } .status-red { color: var(--status-red); }
    .badge-green { background: var(--status-green); color: #fff; padding: 2px 8px; border-radius: 4px; font-size: .8em; }
    .badge-yellow { background: var(--status-yellow); color: #333; padding: 2px 8px; border-radius: 4px; font-size: .8em; }
    .badge-red { background: var(--status-red); color: #fff; padding: 2px 8px; border-radius: 4px; font-size: .8em; }
    .est-card { border: 1px solid var(--pico-muted-border-color); border-radius: 8px; padding: 1rem; margin-bottom: .75rem; }
    .est-card h4 { margin-bottom: .5rem; }
    .est-val { font-size: 1.4em; font-weight: 700; }
    .rule-card { border: 1px solid var(--pico-muted-border-color); border-radius: 8px; padding: 1rem; margin-bottom: .75rem; }
    .rule-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
    .rule-header h4 { margin: 0; }
    .label-pair { display: flex; gap: .5rem; align-items: center; margin-bottom: .25rem; }
    .label-pair input { flex: 1; }
    .tag { display: inline-block; background: var(--pico-primary-background); color: var(--pico-primary-inverse); padding: 2px 8px; border-radius: 12px; font-size: .85em; margin: 2px; cursor: pointer; }
    .tag.selected { outline: 2px solid var(--pico-primary); }
    pre.yaml-preview { background: var(--pico-card-background-color); border: 1px solid var(--pico-muted-border-color); border-radius: 8px; padding: 1rem; overflow-x: auto; max-height: 500px; white-space: pre; font-size: .85em; line-height: 1.4; }
    .yaml-edit { font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace; font-size: .85em; line-height: 1.5; min-height: 300px; resize: vertical; width: 100%; tab-size: 2; white-space: pre; overflow-x: auto; }
    .yaml-toolbar { display: flex; justify-content: space-between; align-items: center; margin-bottom: .25rem; }
    .yaml-toolbar small { color: var(--pico-muted-color); }
    .tab-bar { display: flex; gap: 0; border-bottom: 2px solid var(--pico-muted-border-color); margin-bottom: 1rem; }
    .tab-btn { padding: .5rem 1rem; cursor: pointer; border: none; background: none; font-weight: 600; font-size: .95em; color: var(--pico-muted-color); border-bottom: 2px solid transparent; margin-bottom: -2px; display: flex; align-items: center; gap: .4rem; }
    .tab-btn:hover { color: var(--pico-color); }
    .tab-btn.active { border-bottom-color: var(--pico-primary); color: var(--pico-primary); }
    .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    .dot-green { background: var(--status-green); } .dot-yellow { background: var(--status-yellow); } .dot-red { background: var(--status-red); }
    .btn-row { display: flex; gap: .5rem; margin-top: .5rem; }
    .btn-row button { font-size: .85em; padding: .4rem .8rem; }
    .help-tip { font-size: .85em; color: var(--pico-muted-color); margin-top: .1rem; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; }
    .grid-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; }
    @media (max-width: 768px) { .grid-2, .grid-3, .grid-4 { grid-template-columns: 1fr; } }
    summary { cursor: pointer; font-weight: 600; }
    details details > summary { font-size: 1.1em; font-weight: 700; }
    .copy-ok { color: var(--status-green); font-size: .85em; }
    .storage-rec { background: var(--pico-card-background-color); border: 1px solid var(--pico-muted-border-color); border-radius: 8px; padding: .75rem; margin-top: .5rem; }
    .error-msg { color: var(--status-red); font-size: .85em; margin-top: .25rem; }
    .warn-msg { color: var(--status-yellow); font-size: .85em; margin-top: .25rem; }
    .lint-panel { background: var(--pico-card-background-color); border: 1px solid var(--pico-muted-border-color); border-radius: 8px; padding: .75rem; margin-top: .5rem; font-size: .85em; }
    .lint-item { display: flex; align-items: flex-start; gap: .4rem; margin-bottom: .25rem; }
    .lint-item:last-child { margin-bottom: 0; }
    .lint-icon { font-weight: 700; min-width: 16px; text-align: center; }
    .lint-error .lint-icon { color: var(--status-red); }
    .lint-warn .lint-icon { color: var(--status-yellow); }
    .lint-ok .lint-icon { color: var(--status-green); }
    .section-title { display: flex; align-items: center; gap: .5rem; }
    .theme-toggle { background: none; border: 1px solid var(--pico-muted-border-color); border-radius: 50%; width: 40px; height: 40px; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; transition: border-color .2s; }
    .theme-toggle:hover { border-color: var(--pico-primary); }
    .theme-toggle svg { width: 20px; height: 20px; transition: fill .2s; }
    [data-theme="dark"] .theme-toggle svg { fill: #fbbf24; }
    [data-theme="light"] .theme-toggle svg { fill: #475569; }
    .header-row { display: flex; align-items: center; justify-content: space-between; }
    .logo-title { display: flex; align-items: center; gap: .75rem; }
    .logo-title img { width: 48px; height: 48px; }
  </style>
</head>
<body x-data="configHelper()" class="container">

<header>
  <div class="header-row">
    <div class="logo-title">
      <img src="docs/images/logo.svg" alt="metrics-governor logo" onerror="this.style.display='none'">
      <h1 style="margin-bottom:0">metrics-governor Configuration Helper</h1>
    </div>
    <button class="theme-toggle" @click="toggleTheme()" :aria-label="theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode'" :title="theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode'">
      <!-- Sun icon (shown in dark mode → click to go light) -->
      <template x-if="theme === 'dark'">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm0-3a1 1 0 0 0 1-1V1a1 1 0 1 0-2 0v2a1 1 0 0 0 1 1zm0 18a1 1 0 0 0-1 1v2a1 1 0 1 0 2 0v-2a1 1 0 0 0-1-1zM4.22 5.64a1 1 0 0 0 1.42-1.42l-1.42-1.4a1 1 0 0 0-1.4 1.4l1.4 1.42zm15.56 12.72a1 1 0 0 0-1.42 1.42l1.42 1.4a1 1 0 0 0 1.4-1.4l-1.4-1.42zM4 12a1 1 0 0 0-1-1H1a1 1 0 1 0 0 2h2a1 1 0 0 0 1-1zm19-1h-2a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2zM5.64 19.78a1 1 0 0 0-1.42 0l-1.4 1.42a1 1 0 1 0 1.4 1.4l1.42-1.4a1 1 0 0 0 0-1.42zM19.78 4.22l1.4-1.42a1 1 0 1 0-1.4-1.4l-1.42 1.4a1 1 0 1 0 1.42 1.42z"/></svg>
      </template>
      <!-- Moon icon (shown in light mode → click to go dark) -->
      <template x-if="theme === 'light'">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21.64 13a1 1 0 0 0-1.05-.14 8.05 8.05 0 0 1-3.37.73A8.15 8.15 0 0 1 9.08 5.49a8.59 8.59 0 0 1 .25-2 1 1 0 0 0-.37-1 1 1 0 0 0-1.05-.17A10 10 0 1 0 22 17.29a1 1 0 0 0-.36-1.29zM12 20a8 8 0 0 1-6.95-12A9.94 9.94 0 0 0 19.19 16 8 8 0 0 1 12 20z"/></svg>
      </template>
    </button>
  </div>
  <p>Plan your deployment: estimate resources, build limits rules, and generate ready-to-use config files.</p>
</header>

<main>
  <!-- ====== SECTION 1: INPUTS ====== -->
  <section>
    <details open>
      <summary>
        <span style="display:inline-flex;align-items:center;gap:.75rem;width:100%">
          <span style="font-size:1.25em;font-weight:700">1. Throughput &amp; Environment</span>
          <label style="margin-left:auto;display:flex;align-items:center;gap:.5rem;font-size:.85em" @click.stop>
            <input type="checkbox" x-model="advanced" role="switch"> Advanced
          </label>
        </span>
      </summary>

    <div class="grid-2" style="margin-top:.75rem">
      <label>
        Datapoints/sec
        <input type="number" x-model.number="dps" min="1" step="1000">
        <small class="help-tip">Total incoming metric datapoints per second. ~100k dps/core. <a href="docs/performance.md#throughput" target="_blank">Docs</a></small>
      </label>
      <label>
        Unique metric names
        <input type="number" x-model.number="uniqueMetrics" min="1" step="100">
        <small class="help-tip">Distinct __name__ values. Each gets its own cardinality tracker. <a href="docs/performance.md#cardinality" target="_blank">Docs</a></small>
      </label>
      <label>
        Avg cardinality per metric
        <input type="number" x-model.number="avgCardinality" min="1" step="100">
        <small class="help-tip">Unique label combos per metric. High values (&gt;10k) increase memory. <a href="docs/limits.md" target="_blank">Docs</a></small>
      </label>
      <label>
        CPU cores available
        <input type="number" x-model.number="availableCores" min="1" step="1">
        <small class="help-tip">Total CPU cores for metrics-governor. <a href="docs/performance.md#cpu" target="_blank">Docs</a></small>
      </label>
      <label>
        Target outage buffer
        <div style="display:flex;gap:.25rem">
          <input type="number" x-model.number="targetRetentionVal" min="1" :step="targetRetentionUnit === 'min' ? 5 : 1" style="flex:1">
          <select x-model="targetRetentionUnit" style="width:auto;min-width:80px">
            <option value="min">min</option>
            <option value="hours">hours</option>
            <option value="days">days</option>
          </select>
        </div>
        <small class="help-tip">Data the queue should hold during a backend outage. Queue size is auto-calculated.</small>
      </label>
    </div>

    <template x-if="advanced">
      <div>
        <hr>
        <h4>Advanced Tuning</h4>
        <div class="grid-3">
          <label>
            Avg labels per series
            <input type="number" x-model.number="avgLabels" min="1" max="50" step="1">
            <small class="help-tip">Label key-value pairs per series (typical 3-8). <a href="docs/performance.md#memory" target="_blank">Docs</a></small>
          </label>
          <label>
            Avg label value length
            <input type="number" x-model.number="avgLabelLen" min="1" max="256" step="5">
            <small class="help-tip">Byte length of label values. Longer = more memory. <a href="docs/performance.md#memory" target="_blank">Docs</a></small>
          </label>
          <label>
            Retention window
            <input type="text" x-model="retentionWindow" placeholder="60s">
            <small class="help-tip">How long trackers remember series. <a href="docs/limits.md#window" target="_blank">Docs</a></small>
          </label>
          <label>
            Cardinality mode
            <select x-model="cardinalityMode">
              <option value="bloom">bloom (memory-efficient)</option>
              <option value="exact">exact (precise, higher memory)</option>
              <option value="hybrid">hybrid (bloom+HLL)</option>
            </select>
            <small class="help-tip"><a href="docs/performance.md#cardinality-modes" target="_blank">Docs</a></small>
          </label>
          <label>
            Bloom FPR
            <input type="number" x-model.number="bloomFPR" min="0.001" max="0.5" step="0.005">
            <small class="help-tip">False positive rate (0.01 = 1%). Lower = more memory. <a href="docs/performance.md#bloom-filter" target="_blank">Docs</a></small>
          </label>
          <label>
            HLL threshold
            <input type="number" x-model.number="hllThreshold" min="100" step="1000">
            <small class="help-tip">Hybrid switch point Bloom&rarr;HLL. <a href="docs/performance.md#hybrid" target="_blank">Docs</a></small>
          </label>
          <label>
            Buffer max size
            <input type="number" x-model.number="bufferMaxSize" min="100" step="1000">
            <small class="help-tip">Max write requests in buffer. <a href="docs/performance.md#buffer" target="_blank">Docs</a></small>
          </label>
          <label>
            Buffer batch size
            <input type="number" x-model.number="bufferBatchSize" min="100" step="100">
            <small class="help-tip">Items per export batch. <a href="docs/performance.md#buffer" target="_blank">Docs</a></small>
          </label>
          <label>
            Queue max retries
            <input type="number" x-model.number="queueMaxRetries" min="0" max="100" step="1">
            <small class="help-tip">Retries before data dropped. <a href="docs/performance.md#queue" target="_blank">Docs</a></small>
          </label>
          <label>
            Queue type
            <select x-model="queueType">
              <option value="memory">memory (in-process)</option>
              <option value="disk">disk (persistent)</option>
            </select>
            <small class="help-tip"><a href="docs/performance.md#queue" target="_blank">Docs</a></small>
          </label>
          <label>
            Target outage buffer
            <div style="display:flex;gap:.25rem">
              <input type="number" x-model.number="targetRetentionVal" min="1" :step="targetRetentionUnit === 'min' ? 5 : 1" style="flex:1">
              <select x-model="targetRetentionUnit" style="width:auto;min-width:80px">
                <option value="min">min</option>
                <option value="hours">hours</option>
                <option value="days">days</option>
              </select>
            </div>
            <small class="help-tip">How long to buffer data during backend outage. Auto-sizes queue below.</small>
          </label>
          <label>
            Queue max size MB
            <input type="number" x-model.number="queueMaxSizeMB" min="10" step="50">
            <small class="help-tip" x-text="'Sized for ~' + queueRetentionStr + ' of outage buffer at current throughput.'"></small>
          </label>
          <label>
            CPU cores per pod
            <input type="number" x-model.number="coresPerPod" min="0.5" step="0.5">
            <small class="help-tip">CPU per K8s pod. Determines pod count. <a href="docs/performance.md#scaling" target="_blank">Docs</a></small>
          </label>
          <label>
            Cloud provider
            <select x-model="cloudProvider">
              <option value="none">None</option>
              <option value="aws">AWS</option>
              <option value="azure">Azure</option>
              <option value="gcp">GCP</option>
            </select>
          </label>
        </div>
      </div>
    </template>
    </details>
  </section>

  <!-- ====== SECTION 2+3: ESTIMATION & RULES ====== -->
  <section>
    <div class="tab-bar" style="margin-bottom:0">
      <button class="tab-btn" :class="middleTab === 'estimation' ? 'active' : ''" @click="middleTab = 'estimation'">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width:16px;height:16px;fill:currentColor"><path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2zm0 16H5V5h14v14zM7 10h2v7H7zm4-3h2v10h-2zm4 6h2v4h-2z"/></svg>
        2. Resource Estimation
      </button>
      <button class="tab-btn" :class="middleTab === 'builder' ? 'active' : ''" @click="middleTab = 'builder'">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width:16px;height:16px;fill:currentColor"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>
        3. Limits Rules Builder
      </button>
    </div>

    <template x-if="middleTab === 'estimation'">
    <div style="margin-top:1rem">
    <div class="grid-3">
      <!-- CPU -->
      <div class="est-card">
        <h4>CPU</h4>
        <div class="est-val" :class="cpuStatusClass" x-text="estCores >= 1 ? estCores.toFixed(2) + ' cores' : Math.ceil(estCores * 1000) + 'm'"></div>
        <small x-text="(estCores >= 1 ? Math.ceil(estCores * 1000) + 'm' : estCores.toFixed(2) + ' cores') + ' \u2014 ' + availableCores + ' available (' + cpuUtilPct + '%)'"></small>
        <div><span :class="cpuBadgeClass" x-text="cpuStatusLabel"></span></div>
      </div>

      <!-- Memory -->
      <div class="est-card">
        <h4>Memory (Total)</h4>
        <div class="est-val" x-text="fmtBytes(totalMemory)"></div>
        <small>Trackers: <span x-text="fmtBytes(trackerMemory)"></span></small><br>
        <small>Buffer: <span x-text="fmtBytes(bufferMemory)"></span></small><br>
        <small>Base overhead: ~50 MB</small>
        <template x-if="queueType === 'memory'">
          <small><br>Queue (memory): <span x-text="queueMaxSizeMB + ' MB'"></span></small>
        </template>
      </div>

      <!-- Queue / Disk -->
      <div class="est-card">
        <h4 x-text="queueType === 'disk' ? 'Queue (Disk I/O)' : 'Queue (Memory)'"></h4>
        <template x-if="queueType === 'disk'">
          <div>
            <div class="est-val" x-text="fmtBytes(pvcSize * 1048576)"></div>
            <small>PVC size (incl. 20% headroom)</small><br>
            <small>Write IOPS: <span x-text="writeIOPS"></span></small><br>
            <small>Read IOPS: <span x-text="readIOPS"></span></small><br>
            <small>Total IOPS: <span x-text="totalIOPS"></span></small><br>
            <small>Write throughput: <span x-text="fmtBytes(writeThroughput) + '/s'"></span></small>
          </div>
        </template>
        <template x-if="queueType === 'memory'">
          <div>
            <div class="est-val" x-text="queueMaxSizeMB + ' MB'"></div>
            <small>Added to RAM estimate</small>
          </div>
        </template>
        <div style="margin-top:.5rem;padding-top:.5rem;border-top:1px solid var(--pico-muted-border-color)">
          <small><b>Outage buffer:</b> <span class="status-green" style="font-weight:700" x-text="queueRetentionStr"></span></small><br>
          <small class="help-tip">How long the queue can absorb incoming data if the backend is down, before data starts being dropped.</small>
        </div>
      </div>
    </div>

    <!-- Fit Check -->
    <details open style="margin-top:.5rem">
      <summary style="font-size:.95em">Fit Check &mdash; does it fit your cluster?</summary>
      <div style="margin-top:.5rem">
        <small class="help-tip" style="display:block;margin-bottom:.5rem">Enter your actual available resources to check if the estimated sizing fits. Status shows green when estimates are within budget.</small>
        <div class="grid-4">
          <div>
            <span style="display:flex;align-items:center;gap:.4rem;font-weight:600;font-size:.9em;margin-bottom:.25rem">Pod Override <span class="dot" :class="fitPodOk ? 'dot-green' : 'dot-red'"></span></span>
            <input type="number" x-model.number="podOverride" min="0" step="1" placeholder="0 = auto">
            <small :class="fitPodOk ? 'status-green' : 'status-red'" x-text="fitPodStatusText" style="font-size:.8em"></small>
          </div>
          <div>
            <span style="display:flex;align-items:center;gap:.4rem;font-weight:600;font-size:.9em;margin-bottom:.25rem">Available CPU <span class="dot" :class="fitCpuOk ? 'dot-green' : 'dot-red'"></span></span>
            <div style="display:flex;gap:.25rem">
              <input type="number" x-model.number="fitCpuVal" min="0" :step="fitCpuUnit === 'cores' ? 0.5 : 100" style="flex:1">
              <select x-model="fitCpuUnit" style="width:auto;min-width:90px">
                <option value="cores">cores</option>
                <option value="m">millicores</option>
              </select>
            </div>
            <small :class="fitCpuOk ? 'status-green' : 'status-red'" x-text="fitCpuStatusText"></small>
          </div>
          <div>
            <span style="display:flex;align-items:center;gap:.4rem;font-weight:600;font-size:.9em;margin-bottom:.25rem">Available Memory <span class="dot" :class="fitMemOk ? 'dot-green' : 'dot-red'"></span></span>
            <div style="display:flex;gap:.25rem">
              <input type="number" x-model.number="fitMemVal" min="0" :step="fitMemUnit === 'MB' ? 64 : 0.5" style="flex:1">
              <select x-model="fitMemUnit" style="width:auto;min-width:70px">
                <option value="MB">MB</option>
                <option value="GB">GB</option>
              </select>
            </div>
            <small :class="fitMemOk ? 'status-green' : 'status-red'" x-text="fitMemStatusText"></small>
          </div>
          <div>
            <span style="display:flex;align-items:center;gap:.4rem;font-weight:600;font-size:.9em;margin-bottom:.25rem">Available Disk <span class="dot" :class="fitDiskOk ? 'dot-green' : 'dot-red'"></span></span>
            <div style="display:flex;gap:.25rem">
              <input type="number" x-model.number="fitDiskVal" min="0" :step="fitDiskUnit === 'MB' ? 100 : (fitDiskUnit === 'GB' ? 1 : 0.1)" style="flex:1">
              <select x-model="fitDiskUnit" style="width:auto;min-width:70px">
                <option value="MB">MB</option>
                <option value="GB">GB</option>
                <option value="TB">TB</option>
              </select>
            </div>
            <small :class="fitDiskOk ? 'status-green' : 'status-red'" x-text="fitDiskStatusText"></small>
          </div>
        </div>
      </div>
    </details>

    <!-- Cloud Storage Recommendation -->
    <template x-if="queueType === 'disk' && cloudProvider !== 'none'">
      <div class="storage-rec">
        <h4>Cloud Block Storage Recommendation (<span x-text="cloudProvider.toUpperCase()"></span>)</h4>
        <table>
          <thead><tr><th>Storage Class</th><th>IOPS</th><th>Throughput</th><th>Note</th><th>Recommendation</th></tr></thead>
          <tbody>
            <template x-for="opt in storageOptions" :key="opt.name">
              <tr :style="opt.recommended ? 'font-weight:700' : ''">
                <td x-text="opt.name"></td>
                <td x-text="opt.maxIOPS.toLocaleString()"></td>
                <td x-text="opt.maxThroughput + ' MB/s'"></td>
                <td style="font-size:.8em;color:var(--pico-muted-color)" x-text="opt.note || ''"></td>
                <td>
                  <template x-if="opt.recommended"><span class="badge-green">Recommended</span></template>
                  <template x-if="!opt.recommended && opt.fits"><span style="font-size:.85em">Fits</span></template>
                  <template x-if="!opt.fits"><span class="badge-red">Insufficient</span></template>
                </td>
              </tr>
            </template>
          </tbody>
        </table>
      </div>
    </template>

    <!-- K8s Pod Sizing -->
    <details open>
      <summary>Kubernetes Pod Sizing</summary>
      <div class="grid-4" style="margin-top:.75rem">
        <div class="est-card">
          <h4 x-text="podOverride > 0 ? 'Pods (overridden)' : 'Recommended Pods'"></h4>
          <div class="est-val" x-text="actualPods"></div>
          <template x-if="podOverride > 0 && podOverride !== recommendedPods">
            <small>Recommended: <span x-text="recommendedPods"></span></small>
          </template>
          <small class="help-tip">Based on 70% CPU target utilization per pod</small>
        </div>
        <div class="est-card">
          <h4>Per-Pod CPU</h4>
          <div class="est-val" x-text="perPodCpuReq + 'm'"></div>
          <small x-text="(perPodCpuReq / 1000).toFixed(2) + ' cores'"></small><br>
          <small x-text="'Limit: ' + perPodCpuLimit + 'm (' + (perPodCpuLimit / 1000).toFixed(2) + ' cores)'"></small>
          <br><small class="help-tip">Limit = request &times; 1.5</small>
        </div>
        <div class="est-card">
          <h4>Per-Pod Memory</h4>
          <div class="est-val" x-text="fmtBytes(perPodMemReq)"></div>
          <small x-text="'Limit: ' + fmtBytes(perPodMemLimit)"></small>
          <br><small class="help-tip">Limit = request &times; 1.3</small>
        </div>
        <div class="est-card">
          <h4>Total Cluster</h4>
          <small>CPU: <span x-text="totalClusterCpu + 'm (' + (totalClusterCpu / 1000).toFixed(2) + ' cores)'"></span></small><br>
          <small>Memory: <span x-text="fmtBytes(totalClusterMem)"></span></small><br>
          <template x-if="queueType === 'disk'">
            <small>Disk: <span x-text="fmtBytes(actualPods * queueMaxSizeMB * 1048576)"></span></small>
          </template>
          <br><small>Outage buffer: <span class="status-green" style="font-weight:700" x-text="queueRetentionStr"></span></small>
        </div>
      </div>

      <!-- Sizing rules explanation -->
      <details style="margin-top:.75rem">
        <summary style="font-size:.95em">How these values are calculated</summary>
        <div style="margin-top:.5rem">
          <table style="font-size:.85em">
            <thead><tr><th>Value</th><th>Formula</th><th>Rationale</th></tr></thead>
            <tbody>
              <tr>
                <td><b>Pod count</b></td>
                <td><code>ceil(dps / (cores_per_pod &times; 100k &times; 0.7))</code></td>
                <td>Each core handles ~100k dps; 70% target leaves headroom for GC and spikes</td>
              </tr>
              <tr>
                <td><b>CPU request</b></td>
                <td><code>ceil(dps / pods / 100k &times; 1000)m</code></td>
                <td>Actual expected usage converted to millicores</td>
              </tr>
              <tr>
                <td><b>CPU limit</b></td>
                <td><code>request &times; 1.5</code></td>
                <td>50% headroom for burst handling (traffic spikes, GC pauses)</td>
              </tr>
              <tr>
                <td><b>Memory request</b></td>
                <td><code>ceil(total_memory / pods)</code></td>
                <td>Steady-state memory: trackers + buffer + base overhead + queue</td>
              </tr>
              <tr>
                <td><b>Memory limit</b></td>
                <td><code>request &times; 1.3</code></td>
                <td>30% headroom for Go GC overhead and transient allocations</td>
              </tr>
            </tbody>
          </table>
        </div>
      </details>

      <!-- CNCF / K8s best practices -->
      <details style="margin-top:.5rem">
        <summary style="font-size:.95em">K8s resource sizing best practices</summary>
        <div style="margin-top:.5rem;font-size:.85em;line-height:1.6">
          <p><b>Requests vs Limits</b> &mdash; per the <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" target="_blank">Kubernetes resource management docs</a>:</p>
          <ul style="margin-top:.25rem">
            <li><b>Requests</b> = guaranteed minimum. The scheduler uses this to place pods. Set to actual expected usage so the scheduler can bin-pack efficiently.</li>
            <li><b>Limits</b> = hard ceiling. The kubelet enforces this: CPU is throttled, memory triggers OOM kill. Set above requests to allow for bursts.</li>
            <li><b>CPU</b>: limits &gt; requests is fine &mdash; CPU is compressible and just gets throttled. A 1.5&times; ratio is a common production pattern.</li>
            <li><b>Memory</b>: keep limit closer to request (1.2&ndash;1.3&times;) because exceeding the limit means OOM kill and pod restart. Go's <code>GOMEMLIMIT</code> (auto-detected by metrics-governor) makes GC more aggressive near the limit, preventing most OOM scenarios.</li>
          </ul>

          <p style="margin-top:.75rem"><b>CNCF recommended patterns:</b></p>
          <ul style="margin-top:.25rem">
            <li><b>Guaranteed QoS</b> (request = limit) &mdash; best for latency-sensitive workloads. Pods won't be evicted under memory pressure. Use this if metrics-governor is a critical path component.</li>
            <li><b>Burstable QoS</b> (request &lt; limit) &mdash; better cluster utilization. Pods can burst above requests when resources are free. <b>This tool uses this pattern by default.</b></li>
            <li><b>Always set requests</b> &mdash; pods without requests get <i>BestEffort</i> QoS and are the first to be evicted.</li>
          </ul>

          <p style="margin-top:.75rem"><b>Sizing tips for metrics-governor:</b></p>
          <ul style="margin-top:.25rem">
            <li><b>Right-size over time</b> &mdash; start with these estimates, then observe actual usage via <code>container_cpu_usage_seconds_total</code> and <code>container_memory_working_set_bytes</code> in Prometheus. Adjust requests to P95 actual usage.</li>
            <li><b>Use VPA or Goldilocks</b> &mdash; the <a href="https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler" target="_blank">Vertical Pod Autoscaler</a> or <a href="https://github.com/FairwindsOps/goldilocks" target="_blank">Goldilocks</a> can recommend optimal requests/limits based on observed usage.</li>
            <li><b>HPA for horizontal scaling</b> &mdash; metrics-governor's Helm chart supports HPA. Scale on CPU utilization (default 80%) or custom metrics like <code>metrics_governor_datapoints_total</code>.</li>
            <li><b>PodDisruptionBudget</b> &mdash; set <code>minAvailable: 1</code> to ensure at least one pod stays running during node drains and cluster upgrades.</li>
            <li><b>Topology spread</b> &mdash; for high availability, use <code>topologySpreadConstraints</code> to distribute pods across zones/nodes.</li>
          </ul>

          <p style="margin-top:.75rem;color:var(--pico-muted-color)"><small>References: <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" target="_blank">K8s Resource Management</a> &bull; <a href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/" target="_blank">QoS Classes</a> &bull; <a href="https://www.cncf.io/blog/2023/09/29/kubernetes-resource-management-a-practitioners-guide/" target="_blank">CNCF Resource Management Guide</a> &bull; <a href="https://home.robusta.dev/blog/stop-using-cpu-limits" target="_blank">Stop Using CPU Limits</a></small></p>
        </div>
      </details>
    </details>
    </div>
    </template>

    <template x-if="middleTab === 'builder'">
    <div style="margin-top:1rem">

    <details open>
      <summary>Global Defaults</summary>
      <div class="grid-3" style="margin-top:.75rem">
        <label>
          Default max cardinality
          <input type="number" x-model.number="defaultMaxCardinality" min="0" step="1000">
        </label>
        <label>
          Default max datapoints rate
          <input type="number" x-model.number="defaultMaxDpRate" min="0" step="10000">
        </label>
        <label>
          Default action
          <select x-model="defaultAction">
            <option value="log">log</option>
            <option value="drop">drop</option>
            <option value="adaptive">adaptive</option>
          </select>
        </label>
      </div>
    </details>

    <div style="margin-top:1rem">
      <button @click="addRule()" class="outline">+ Add Rule</button>
    </div>

    <template x-for="(rule, idx) in rules" :key="rule.id">
      <div class="rule-card" style="margin-top:.75rem">
        <div class="rule-header" @click="rule.expanded = !rule.expanded">
          <h4 x-text="rule.name || 'Untitled Rule #' + (idx + 1)"></h4>
          <div style="display:flex;gap:.25rem;align-items:center">
            <button class="outline secondary" style="padding:2px 8px;font-size:.8em" @click.stop="moveRule(idx, -1)" :disabled="idx === 0">&uarr;</button>
            <button class="outline secondary" style="padding:2px 8px;font-size:.8em" @click.stop="moveRule(idx, 1)" :disabled="idx === rules.length - 1">&darr;</button>
            <button class="outline" style="padding:2px 8px;font-size:.8em;color:var(--status-red)" @click.stop="rules.splice(idx, 1)">Delete</button>
            <span x-text="rule.expanded ? '&#9660;' : '&#9654;'" style="font-size:.8em"></span>
          </div>
        </div>
        <template x-if="rule.expanded">
          <div style="margin-top:.75rem">
            <div class="grid-2">
              <label>
                Name
                <input type="text" x-model="rule.name" placeholder="e.g. high-cardinality-protection">
              </label>
              <label>
                Match metric_name (regex)
                <input type="text" x-model="rule.matchMetricName" placeholder="e.g. http_request_.*">
              </label>
            </div>

            <fieldset>
              <legend>Match Labels</legend>
              <template x-for="(lbl, li) in rule.labels" :key="li">
                <div class="label-pair">
                  <input type="text" x-model="lbl.key" placeholder="key">
                  <input type="text" x-model="lbl.value" placeholder="value">
                  <button class="outline" style="padding:2px 8px;font-size:.8em;color:var(--status-red)" @click="rule.labels.splice(li, 1)">x</button>
                </div>
              </template>
              <button class="outline secondary" style="font-size:.8em;padding:4px 10px" @click="rule.labels.push({key:'',value:''})">+ Label</button>
            </fieldset>

            <div class="grid-3">
              <label>
                Max cardinality
                <input type="number" x-model.number="rule.maxCardinality" min="0" step="1000">
              </label>
              <label>
                Max datapoints rate
                <input type="number" x-model.number="rule.maxDpRate" min="0" step="10000">
              </label>
              <label>
                Action
                <select x-model="rule.action">
                  <option value="log">log</option>
                  <option value="drop">drop</option>
                  <option value="adaptive">adaptive</option>
                </select>
              </label>
            </div>

            <div class="grid-2">
              <label>
                Window
                <input type="text" x-model="rule.window" placeholder="e.g. 60s">
              </label>
              <div>
                <label>Group By</label>
                <div style="border:1px solid var(--pico-muted-border-color);border-radius:8px;padding:.5rem;min-height:42px;display:flex;flex-wrap:wrap;align-items:center;gap:4px">
                  <template x-for="(g, gi) in rule.groupBy" :key="gi">
                    <span class="tag" style="display:inline-flex;align-items:center;gap:2px">
                      <span x-text="g"></span>
                      <span style="cursor:pointer;font-weight:700;margin-left:2px" @click="rule.groupBy.splice(gi, 1)">&times;</span>
                    </span>
                  </template>
                  <input type="text" x-model="rule.customGroupBy" placeholder="type label, press Enter" style="border:none;outline:none;background:transparent;flex:1;min-width:120px;font-size:.85em;padding:4px;margin:0" @keydown.enter.prevent="addGroupByLabel(rule)" @keydown.comma.prevent="addGroupByLabel(rule)" @keydown.backspace="if(!rule.customGroupBy && rule.groupBy.length) rule.groupBy.pop()">
                </div>
                <div style="margin-top:4px;display:flex;align-items:center;gap:6px;flex-wrap:wrap">
                  <small class="help-tip" style="margin:0">Quick add:</small>
                  <template x-for="s in groupByOptions" :key="s">
                    <button class="outline secondary" style="font-size:.75em;padding:2px 8px;margin:0;border-radius:12px" @click="if(!rule.groupBy.includes(s)) rule.groupBy.push(s)" x-text="'+ ' + s" :disabled="rule.groupBy.includes(s)"></button>
                  </template>
                  <small class="help-tip" style="margin:0">Labels used to track &amp; identify top offenders for adaptive action.</small>
                </div>
              </div>
            </div>
          </div>
        </template>
      </div>
    </template>
    </div>
    </template>
  </section>

  <!-- ====== SECTION 4: LIVE CONFIG PREVIEW ====== -->
  <section>
    <details open>
      <summary style="font-size:1.25em;font-weight:700">4. Config Preview &amp; Export</summary>

    <div class="tab-bar">
      <button class="tab-btn" :class="activeTab === 'helm' ? 'active' : ''" @click="activeTab = 'helm'">
        <span class="dot" :class="!helmValid ? 'dot-red' : helmHasWarns ? 'dot-yellow' : 'dot-green'"></span> Helm values.yaml
      </button>
      <button class="tab-btn" :class="activeTab === 'app' ? 'active' : ''" @click="activeTab = 'app'">
        <span class="dot" :class="!appValid ? 'dot-red' : appHasWarns ? 'dot-yellow' : 'dot-green'"></span> App config.yaml
      </button>
      <button class="tab-btn" :class="activeTab === 'limits' ? 'active' : ''" @click="activeTab = 'limits'">
        <span class="dot" :class="!limitsValid ? 'dot-red' : limitsHasWarns ? 'dot-yellow' : 'dot-green'"></span> Limits rules YAML
      </button>
    </div>

    <!-- Helm values.yaml -->
    <template x-if="activeTab === 'helm'">
      <div>
        <div class="yaml-toolbar">
          <small>Edit YAML directly — changes reflect in inputs and estimations</small>
          <button class="outline secondary" style="font-size:.8em;padding:2px 10px;margin:0" @click="resetYamlText('helm')">Reset to generated</button>
        </div>
        <textarea class="yaml-edit" x-model.debounce.500ms="helmText" @focus="editingTab='helm'" @blur="editingTab=null" spellcheck="false"></textarea>
        <div class="lint-panel">
          <template x-for="issue in helmLint" :key="issue.msg">
            <div class="lint-item" :class="'lint-' + issue.type">
              <span class="lint-icon" x-text="issue.type === 'error' ? '\u2716' : issue.type === 'warn' ? '\u26A0' : '\u2714'"></span>
              <span x-text="issue.msg"></span>
            </div>
          </template>
        </div>
        <div class="btn-row">
          <button @click="copyToClipboard(helmText, 'helm')">Copy to Clipboard</button>
          <button class="outline" @click="downloadFile(helmText, 'values.yaml')">Download values.yaml</button>
          <span class="copy-ok" x-show="copyOk === 'helm'" x-transition>Copied!</span>
        </div>
      </div>
    </template>

    <!-- App config.yaml -->
    <template x-if="activeTab === 'app'">
      <div>
        <div class="yaml-toolbar">
          <small>Edit YAML directly — changes reflect in inputs and estimations</small>
          <button class="outline secondary" style="font-size:.8em;padding:2px 10px;margin:0" @click="resetYamlText('app')">Reset to generated</button>
        </div>
        <textarea class="yaml-edit" x-model.debounce.500ms="appText" @focus="editingTab='app'" @blur="editingTab=null" spellcheck="false"></textarea>
        <div class="lint-panel">
          <template x-for="issue in appLint" :key="issue.msg">
            <div class="lint-item" :class="'lint-' + issue.type">
              <span class="lint-icon" x-text="issue.type === 'error' ? '\u2716' : issue.type === 'warn' ? '\u26A0' : '\u2714'"></span>
              <span x-text="issue.msg"></span>
            </div>
          </template>
        </div>
        <div class="btn-row">
          <button @click="copyToClipboard(appText, 'app')">Copy to Clipboard</button>
          <button class="outline" @click="downloadFile(appText, 'config.yaml')">Download config.yaml</button>
          <span class="copy-ok" x-show="copyOk === 'app'" x-transition>Copied!</span>
        </div>
      </div>
    </template>

    <!-- Limits rules YAML -->
    <template x-if="activeTab === 'limits'">
      <div>
        <div class="yaml-toolbar">
          <small>Edit YAML directly — changes reflect in inputs and estimations</small>
          <button class="outline secondary" style="font-size:.8em;padding:2px 10px;margin:0" @click="resetYamlText('limits')">Reset to generated</button>
        </div>
        <textarea class="yaml-edit" x-model.debounce.500ms="limitsText" @focus="editingTab='limits'" @blur="editingTab=null" spellcheck="false"></textarea>
        <div class="lint-panel">
          <template x-for="issue in limitsLint" :key="issue.msg">
            <div class="lint-item" :class="'lint-' + issue.type">
              <span class="lint-icon" x-text="issue.type === 'error' ? '\u2716' : issue.type === 'warn' ? '\u26A0' : '\u2714'"></span>
              <span x-text="issue.msg"></span>
            </div>
          </template>
        </div>
        <div class="btn-row">
          <button @click="copyToClipboard(limitsText, 'limits')">Copy to Clipboard</button>
          <button class="outline" @click="downloadFile(limitsText, 'limits.yaml')">Download limits.yaml</button>
          <span class="copy-ok" x-show="copyOk === 'limits'" x-transition>Copied!</span>
        </div>
      </div>
    </template>
    </details>
  </section>
</main>

<footer>
  <small>metrics-governor Configuration Helper &mdash; open this file directly in your browser, no build step needed.</small>
</footer>

<script>
function configHelper() {
  return {
    // ---- Theme ----
    theme: localStorage.getItem('mg-theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'),
    init() {
      this.applyTheme();
      this.$watch('theme', () => this.applyTheme());
      this.loadState();
      // Auto-save all reactive state on any change (debounced)
      let saveTimer = null;
      const fields = [
        'dps','uniqueMetrics','avgCardinality','availableCores','advanced',
        'avgLabels','avgLabelLen','retentionWindow','cardinalityMode','bloomFPR',
        'hllThreshold','bufferMaxSize','bufferBatchSize','queueMaxRetries',
        'queueType','queueMaxSizeMB','targetRetentionVal','targetRetentionUnit','coresPerPod','cloudProvider',
        'fitCpuVal','fitCpuUnit','fitMemVal','fitMemUnit','fitDiskVal','fitDiskUnit',
        'podOverride',
        'defaultMaxCardinality','defaultMaxDpRate','defaultAction',
        'rules','middleTab','activeTab',
      ];
      for (const f of fields) {
        this.$watch(f, () => {
          clearTimeout(saveTimer);
          saveTimer = setTimeout(() => this.saveState(), 300);
        }, { deep: true });
      }
      // Auto-size queue when retention target or throughput changes
      this.$watch('targetRetentionVal', () => this.autoSizeQueue());
      this.$watch('targetRetentionUnit', () => this.autoSizeQueue());
      this.$watch('dps', () => this.autoSizeQueue());
      this.$watch('bufferBatchSize', () => this.autoSizeQueue());

      // Initialize textarea content from generated YAML
      this.helmText = this.helmYaml;
      this.appText = this.appYaml;
      this.limitsText = this.limitsYaml;

      // Inputs → Textarea: sync generated YAML to textarea when textarea is not focused
      this.$watch('helmYaml', (val) => {
        if (this.editingTab !== 'helm' && !this._updatingFromYaml) this.helmText = val;
      });
      this.$watch('appYaml', (val) => {
        if (this.editingTab !== 'app' && !this._updatingFromYaml) this.appText = val;
      });
      this.$watch('limitsYaml', (val) => {
        if (this.editingTab !== 'limits' && !this._updatingFromYaml) this.limitsText = val;
      });

      // Textarea → Inputs: parse edited YAML back into state (debounced via x-model.debounce)
      this.$watch('helmText', (val) => {
        if (!this._updatingFromYaml && this.editingTab === 'helm') this.applyHelmText(val);
      });
      this.$watch('appText', (val) => {
        if (!this._updatingFromYaml && this.editingTab === 'app') this.applyAppText(val);
      });
      this.$watch('limitsText', (val) => {
        if (!this._updatingFromYaml && this.editingTab === 'limits') this.applyLimitsText(val);
      });
    },
    autoSizeQueue() {
      // queueMaxSizeMB = writeThroughput (bytes/sec) * targetRetentionMin * 60 / 1MB
      const bytesPerSec = (this.dps / this.bufferBatchSize) * (this.bufferBatchSize * (this.avgLabels * (10 + this.avgLabelLen) + 16)) * 0.3;
      const needed = Math.ceil(bytesPerSec * this.targetRetentionMin * 60 / 1048576);
      this.queueMaxSizeMB = Math.max(10, needed);
    },
    saveState() {
      const state = {};
      const fields = [
        'dps','uniqueMetrics','avgCardinality','availableCores','advanced',
        'avgLabels','avgLabelLen','retentionWindow','cardinalityMode','bloomFPR',
        'hllThreshold','bufferMaxSize','bufferBatchSize','queueMaxRetries',
        'queueType','queueMaxSizeMB','targetRetentionVal','targetRetentionUnit','coresPerPod','cloudProvider',
        'fitCpuVal','fitCpuUnit','fitMemVal','fitMemUnit','fitDiskVal','fitDiskUnit',
        'podOverride',
        'defaultMaxCardinality','defaultMaxDpRate','defaultAction',
        'rules','middleTab','activeTab','ruleIdCounter',
      ];
      for (const f of fields) state[f] = this[f];
      try { localStorage.setItem('mg-config-state', JSON.stringify(state)); } catch(e) {}
    },
    loadState() {
      try {
        const raw = localStorage.getItem('mg-config-state');
        if (!raw) return;
        const state = JSON.parse(raw);
        for (const [k, v] of Object.entries(state)) {
          if (v !== undefined && v !== null && k in this) this[k] = v;
        }
      } catch(e) {}
    },
    applyTheme() {
      document.documentElement.setAttribute('data-theme', this.theme);
      localStorage.setItem('mg-theme', this.theme);
    },
    toggleTheme() {
      this.theme = this.theme === 'dark' ? 'light' : 'dark';
    },

    // ---- Simple inputs ----
    dps: 50000,
    uniqueMetrics: 1000,
    avgCardinality: 100,
    availableCores: 4,

    // ---- Advanced inputs ----
    advanced: false,
    avgLabels: 5,
    avgLabelLen: 20,
    retentionWindow: '60s',
    cardinalityMode: 'bloom',
    bloomFPR: 0.01,
    hllThreshold: 10000,
    bufferMaxSize: 5000,
    bufferBatchSize: 1000,
    queueMaxRetries: 3,
    queueType: 'disk',
    queueMaxSizeMB: 100,
    targetRetentionVal: 10,
    targetRetentionUnit: 'min',
    fitCpuVal: 4,
    fitCpuUnit: 'cores',
    fitMemVal: 512,
    fitMemUnit: 'MB',
    fitDiskVal: 500,
    fitDiskUnit: 'MB',
    podOverride: 0,
    coresPerPod: 2,
    cloudProvider: 'aws',

    // ---- Limits defaults ----
    defaultMaxCardinality: 100000,
    defaultMaxDpRate: 1000000,
    defaultAction: 'log',

    // ---- Rules ----
    rules: [],
    ruleIdCounter: 0,
    groupByOptions: ['service', 'env', 'namespace', 'cluster', 'job', 'instance'],

    // ---- UI state ----
    middleTab: 'estimation',
    activeTab: 'helm',
    copyOk: null,

    // ---- Bidirectional YAML editing state ----
    helmText: '',
    appText: '',
    limitsText: '',
    editingTab: null,
    _updatingFromYaml: false,

    // ---- Helpers ----
    addRule() {
      this.ruleIdCounter++;
      this.rules.push({
        id: this.ruleIdCounter,
        name: '',
        matchMetricName: '',
        labels: [],
        maxCardinality: 50000,
        maxDpRate: 500000,
        action: 'log',
        groupBy: [],
        customGroupBy: '',
        window: '60s',
        expanded: true,
      });
    },
    moveRule(idx, dir) {
      const target = idx + dir;
      if (target < 0 || target >= this.rules.length) return;
      const tmp = this.rules[idx];
      this.rules[idx] = this.rules[target];
      this.rules[target] = tmp;
    },
    toggleGroupBy(rule, g) {
      const i = rule.groupBy.indexOf(g);
      if (i >= 0) rule.groupBy.splice(i, 1);
      else rule.groupBy.push(g);
    },
    addGroupByLabel(rule) {
      const val = rule.customGroupBy.replace(/,/g, '').trim();
      if (val && !rule.groupBy.includes(val)) {
        rule.groupBy.push(val);
      }
      rule.customGroupBy = '';
    },

    // ---- Formatters ----
    fmtBytes(b) {
      if (b < 1024) return b + ' B';
      if (b < 1048576) return (b / 1024).toFixed(1) + ' KB';
      if (b < 1073741824) return (b / 1048576).toFixed(1) + ' MB';
      return (b / 1073741824).toFixed(2) + ' GB';
    },

    // ---- CPU estimation ----
    get estCores() { return this.dps / 100000; },
    get cpuUtil() { return this.estCores / this.availableCores; },
    get cpuUtilPct() { return (this.cpuUtil * 100).toFixed(0); },
    get cpuStatusClass() {
      if (this.cpuUtil <= 0.7) return 'status-green';
      if (this.cpuUtil <= 0.9) return 'status-yellow';
      return 'status-red';
    },
    get cpuBadgeClass() {
      if (this.cpuUtil <= 0.7) return 'badge-green';
      if (this.cpuUtil <= 0.9) return 'badge-yellow';
      return 'badge-red';
    },
    get cpuStatusLabel() {
      if (this.cpuUtil <= 0.7) return 'OK';
      if (this.cpuUtil <= 0.9) return 'Warning';
      return 'Over capacity';
    },

    // ---- Memory estimation ----
    get totalSeries() { return this.uniqueMetrics * this.avgCardinality; },
    get bloomBitsPerTracker() {
      const n = this.avgCardinality;
      const p = this.bloomFPR;
      return Math.ceil(-n * Math.log(p) / (Math.log(2) * Math.log(2)));
    },
    get trackerMemory() {
      const mode = this.cardinalityMode;
      if (mode === 'exact') return this.totalSeries * 75;
      if (mode === 'bloom') return this.uniqueMetrics * Math.ceil(this.bloomBitsPerTracker / 8);
      // hybrid: bloom up to threshold, HLL (12KB) above
      const bloomTrackers = Math.min(this.uniqueMetrics, Math.floor(this.uniqueMetrics * (this.hllThreshold / this.avgCardinality)));
      const hllTrackers = this.uniqueMetrics - bloomTrackers;
      return bloomTrackers * Math.ceil(this.bloomBitsPerTracker / 8) + hllTrackers * 12288;
    },
    get avgSeriesSize() { return this.avgLabels * (10 + this.avgLabelLen) + 16; },
    get bufferMemory() { return this.bufferMaxSize * this.avgSeriesSize; },
    get baseOverhead() { return 50 * 1048576; },
    get queueMemoryAdd() { return this.queueType === 'memory' ? this.queueMaxSizeMB * 1048576 : 0; },
    get totalMemory() { return this.trackerMemory + this.bufferMemory + this.baseOverhead + this.queueMemoryAdd; },

    // ---- Queue disk estimation ----
    get avgBatchBytes() { return this.bufferBatchSize * this.avgSeriesSize; },
    get compressionRatio() { return 0.3; },
    get writeThroughput() { return (this.dps / this.bufferBatchSize) * this.avgBatchBytes * this.compressionRatio; },
    get writeIOPS() { return Math.ceil(this.dps / this.bufferBatchSize); },
    get readIOPS() { return Math.ceil(this.writeIOPS * 0.1); },
    get totalIOPS() { return this.writeIOPS + this.readIOPS; },
    get pvcSize() { return Math.ceil(this.queueMaxSizeMB * 1.2); },

    // ---- Queue retention ----
    get queueRetentionSec() {
      if (this.writeThroughput <= 0) return Infinity;
      return (this.queueMaxSizeMB * 1048576) / this.writeThroughput;
    },
    get queueRetentionStr() {
      const s = this.queueRetentionSec;
      if (!isFinite(s)) return 'unlimited';
      if (s < 60) return Math.round(s) + 's';
      if (s < 3600) return Math.round(s / 60) + ' min';
      if (s < 86400) return (s / 3600).toFixed(1) + ' hours';
      return (s / 86400).toFixed(1) + ' days';
    },

    // ---- Fit check (normalized) ----
    get targetRetentionMin() {
      if (this.targetRetentionUnit === 'hours') return this.targetRetentionVal * 60;
      if (this.targetRetentionUnit === 'days') return this.targetRetentionVal * 1440;
      return this.targetRetentionVal;
    },
    get fitCpuCores() { return this.fitCpuUnit === 'm' ? this.fitCpuVal / 1000 : this.fitCpuVal; },
    get fitMemMB() { return this.fitMemUnit === 'GB' ? this.fitMemVal * 1024 : this.fitMemVal; },
    get fitDiskMB() {
      if (this.fitDiskUnit === 'GB') return this.fitDiskVal * 1024;
      if (this.fitDiskUnit === 'TB') return this.fitDiskVal * 1048576;
      return this.fitDiskVal;
    },
    get estMemMB() { return this.totalMemory / 1048576; },
    get estDiskMB() { return this.queueType === 'disk' ? this.pvcSize : 0; },
    get fitCpuOk() { return this.estCores <= this.fitCpuCores; },
    get fitMemOk() { return this.estMemMB <= this.fitMemMB; },
    get fitDiskOk() { return this.estDiskMB <= this.fitDiskMB; },
    get fitCpuStatusText() {
      const avail = this.fitCpuCores;
      const need = this.estCores;
      if (need <= avail) return 'OK \u2014 ' + ((1 - need / avail) * 100).toFixed(0) + '% headroom (' + need.toFixed(2) + ' of ' + avail.toFixed(2) + ' cores)';
      return 'Over by ' + (need - avail).toFixed(2) + ' cores (' + Math.ceil(need * 1000) + 'm needed)';
    },
    get fitMemStatusText() {
      const avail = this.fitMemMB;
      const need = this.estMemMB;
      if (need <= avail) return 'OK \u2014 ' + ((1 - need / avail) * 100).toFixed(0) + '% headroom (' + this.fmtBytes(need * 1048576) + ' of ' + this.fmtBytes(avail * 1048576) + ')';
      return 'Over by ' + this.fmtBytes((need - avail) * 1048576) + ' (' + this.fmtBytes(need * 1048576) + ' needed)';
    },
    get fitDiskStatusText() {
      if (this.queueType !== 'disk') return 'N/A \u2014 memory queue selected';
      const avail = this.fitDiskMB;
      const need = this.estDiskMB;
      if (need <= avail) return 'OK \u2014 ' + ((1 - need / avail) * 100).toFixed(0) + '% headroom (' + this.fmtBytes(need * 1048576) + ' of ' + this.fmtBytes(avail * 1048576) + ')';
      return 'Over by ' + this.fmtBytes((need - avail) * 1048576) + ' (' + this.fmtBytes(need * 1048576) + ' needed)';
    },

    // ---- Cloud storage ----
    get storageOptions() {
      const iops = this.totalIOPS;
      const tput = this.writeThroughput / 1048576; // MB/s
      const sizeGiB = Math.max(1, Math.ceil(this.pvcSize / 1024));
      const sizeTiB = sizeGiB / 1024;

      // AWS st1: baseline 40 MB/s per TiB, burst 250 MB/s per TiB, max 500 MB/s
      const st1Base = Math.min(500, Math.max(5, Math.round(sizeTiB * 40)));
      const st1Burst = Math.min(500, Math.max(31, Math.round(sizeTiB * 250)));
      // GCP size-dependent write performance
      const pdSsdIOPS = Math.min(100000, Math.max(300, sizeGiB * 30));
      const pdBalIOPS = Math.min(80000, Math.max(3000, sizeGiB * 6));
      const pdStdIOPS = Math.min(15000, Math.max(75, Math.round(sizeGiB * 1.5)));

      const tables = {
        aws: [
          { name: 'gp3', maxIOPS: 80000, maxThroughput: 2000, note: '3K IOPS + 125 MB/s baseline included; provisionable' },
          { name: 'io2 Block Express', maxIOPS: 256000, maxThroughput: 4000, note: 'Provisioned; up to 1000 IOPS/GiB' },
          { name: 'io1', maxIOPS: 64000, maxThroughput: 1000, note: 'Provisioned; up to 50 IOPS/GiB' },
          { name: 'st1 (HDD)', maxIOPS: 500, maxThroughput: st1Base, note: `Burst credits: ${st1Base} MB/s baseline, ${st1Burst} MB/s burst at ${sizeGiB} GiB` },
        ],
        azure: [
          { name: 'Premium SSD v1', maxIOPS: 20000, maxThroughput: 900, note: 'Tier-based; credit burst up to 30K IOPS/1000 MB/s' },
          { name: 'Premium SSD v2', maxIOPS: 80000, maxThroughput: 1200, note: '3K IOPS + 125 MB/s baseline; provisionable' },
          { name: 'Ultra Disk', maxIOPS: 400000, maxThroughput: 10000, note: 'Fully provisionable IOPS/throughput' },
          { name: 'Standard SSD', maxIOPS: 6000, maxThroughput: 750, note: 'Tier-based; credit-based bursting' },
        ],
        gcp: [
          { name: 'pd-ssd', maxIOPS: pdSsdIOPS, maxThroughput: 1200, note: `30 write IOPS/GiB \u2192 ${pdSsdIOPS.toLocaleString()} at ${sizeGiB} GiB` },
          { name: 'pd-balanced', maxIOPS: pdBalIOPS, maxThroughput: 1200, note: `6 write IOPS/GiB \u2192 ${pdBalIOPS.toLocaleString()} at ${sizeGiB} GiB` },
          { name: 'pd-standard', maxIOPS: pdStdIOPS, maxThroughput: 400, note: `1.5 write IOPS/GiB \u2192 ${pdStdIOPS.toLocaleString()} at ${sizeGiB} GiB` },
        ],
      };
      const opts = (tables[this.cloudProvider] || []).map(o => ({
        ...o,
        fits: iops <= o.maxIOPS && tput <= o.maxThroughput,
        recommended: false,
      }));
      // First that fits is recommended
      const rec = opts.find(o => o.fits);
      if (rec) rec.recommended = true;
      return opts;
    },
    get recommendedStorageClass() {
      const rec = this.storageOptions.find(o => o.recommended);
      if (!rec) return '';
      const nameMap = {
        'gp3': 'gp3', 'io2 Block Express': 'io2', 'io1': 'io1', 'st1 (HDD)': 'st1',
        'Premium SSD v1': 'managed-premium', 'Premium SSD v2': 'managed-premium-v2', 'Ultra Disk': 'ultra-disk', 'Standard SSD': 'managed-standard',
        'pd-ssd': 'pd-ssd', 'pd-balanced': 'pd-balanced', 'pd-standard': 'pd-standard',
      };
      return nameMap[rec.name] || rec.name;
    },

    // ---- K8s pod sizing ----
    get maxThroughputPerPod() { return this.coresPerPod * 100000 * 0.7; },
    get recommendedPods() { return Math.max(1, Math.ceil(this.dps / this.maxThroughputPerPod)); },
    get actualPods() { return this.podOverride > 0 ? this.podOverride : this.recommendedPods; },
    get perPodCpuReq() { return Math.ceil(this.dps / this.actualPods / 100000 * 1000); },
    get perPodCpuLimit() { return Math.ceil(this.perPodCpuReq * 1.5); },
    get perPodMemReq() { return Math.ceil(this.totalMemory / this.actualPods); },
    get perPodMemLimit() { return Math.ceil(this.perPodMemReq * 1.3); },
    get totalClusterCpu() { return this.actualPods * this.perPodCpuReq; },
    get totalClusterMem() { return this.actualPods * this.perPodMemReq; },
    get fitPodOk() { return this.podOverride <= 0 || this.podOverride >= this.recommendedPods; },
    get fitPodStatusText() {
      if (this.podOverride <= 0) return 'Using recommended: ' + this.recommendedPods + ' pods';
      if (this.podOverride >= this.recommendedPods) return 'OK \u2014 ' + this.podOverride + ' pods (\u2265 ' + this.recommendedPods + ' recommended)';
      return 'Below recommended (' + this.recommendedPods + ') \u2014 may cause CPU overload';
    },

    // ---- YAML generation ----
    get helmYaml() {
      const csi = { aws: 'ebs.csi.aws.com', azure: 'disk.csi.azure.com', gcp: 'pd.csi.storage.gke.io' };
      const diskTypeMap = { aws: { 'gp3': 'gp3', 'io2': 'io2', 'io1': 'io1', 'st1': 'st1' }, azure: { 'managed-premium': 'Premium_LRS', 'managed-premium-v2': 'PremiumV2_LRS', 'ultra-disk': 'UltraSSD_LRS', 'managed-standard': 'StandardSSD_LRS' }, gcp: { 'pd-ssd': 'pd-ssd', 'pd-balanced': 'pd-balanced', 'pd-standard': 'pd-standard' } };
      const recClass = this.recommendedStorageClass;
      const diskTypes = { aws: (diskTypeMap.aws[recClass] || 'gp3'), azure: (diskTypeMap.azure[recClass] || 'Premium_LRS'), gcp: (diskTypeMap.gcp[recClass] || 'pd-ssd') };
      let y = '';
      y += `replicaCount: ${this.actualPods}\n`;
      y += `\nresources:\n`;
      y += `  requests:\n`;
      y += `    cpu: "${this.perPodCpuReq}m"\n`;
      y += `    memory: "${Math.ceil(this.perPodMemReq / 1048576)}Mi"\n`;
      y += `  limits:\n`;
      y += `    cpu: "${this.perPodCpuLimit}m"\n`;
      y += `    memory: "${Math.ceil(this.perPodMemLimit / 1048576)}Mi"\n`;
      y += `\nconfig:\n`;
      y += `  grpcListen: ":4317"\n`;
      y += `  httpListen: ":4318"\n`;
      y += `  statsAddr: ":9090"\n`;
      y += `  exporterEndpoint: "localhost:4317"\n`;
      y += `  exporterProtocol: "grpc"\n`;
      y += `  exporterInsecure: true\n`;
      y += `  bufferSize: ${this.bufferMaxSize}\n`;
      y += `  batchSize: ${this.bufferBatchSize}\n`;
      y += `  flushInterval: "5s"\n`;
      y += `\nlimits:\n`;
      y += `  enabled: true\n`;
      y += `  config: |\n`;
      // Inline limits
      const limitsLines = this.limitsYaml.split('\n');
      for (const line of limitsLines) {
        y += `    ${line}\n`;
      }
      y += `\nqueue:\n`;
      y += `  enabled: true\n`;
      y += `  path: "/data/queue"\n`;
      y += `  maxSize: 10000\n`;
      y += `  maxBytes: ${this.queueMaxSizeMB * 1048576}\n`;
      y += `  retryInterval: "5s"\n`;
      y += `  maxRetryDelay: "5m"\n`;
      y += `  fullBehavior: "drop_oldest"\n`;
      y += `\nperformance:\n`;
      y += `  stringInterning: true\n`;
      y += `  internMaxValueLength: 64\n`;
      if (this.queueType === 'disk') {
        y += `\npersistence:\n`;
        y += `  enabled: true\n`;
        y += `  storageClassName: "${this.recommendedStorageClass}"\n`;
        y += `  accessModes:\n`;
        y += `    - ReadWriteOnce\n`;
        y += `  size: "${this.pvcSize}Mi"\n`;
        if (this.cloudProvider !== 'none') {
          const driver = csi[this.cloudProvider] || 'kubernetes.io/no-provisioner';
          const dt = diskTypes[this.cloudProvider] || 'default';
          y += `\n# StorageClass example (apply separately if needed)\n`;
          y += `# ---\n`;
          y += `# apiVersion: storage.k8s.io/v1\n`;
          y += `# kind: StorageClass\n`;
          y += `# metadata:\n`;
          y += `#   name: metrics-governor-queue\n`;
          y += `# provisioner: ${driver}\n`;
          y += `# parameters:\n`;
          y += `#   type: ${dt}\n`;
          if (this.cloudProvider === 'aws') {
            y += `#   iops: "${this.totalIOPS}"\n`;
            y += `#   throughput: "${Math.ceil(this.writeThroughput / 1048576)}"\n`;
          }
          y += `# volumeBindingMode: WaitForFirstConsumer\n`;
        }
      }
      return y;
    },

    get appYaml() {
      let y = '';
      y += `receiver:\n`;
      y += `  grpc:\n`;
      y += `    address: ":4317"\n`;
      y += `  http:\n`;
      y += `    address: ":4318"\n`;
      y += `\nexporter:\n`;
      y += `  endpoint: "localhost:4317"\n`;
      y += `  protocol: "grpc"\n`;
      y += `  insecure: true\n`;
      y += `  timeout: 30s\n`;
      y += `\nbuffer:\n`;
      y += `  size: ${this.bufferMaxSize}\n`;
      y += `  batch_size: ${this.bufferBatchSize}\n`;
      y += `  flush_interval: 5s\n`;
      y += `\nstats:\n`;
      y += `  address: ":9090"\n`;
      y += `\nlimits:\n`;
      y += `  dry_run: false\n`;
      y += `\nperformance:\n`;
      y += `  cardinality_mode: "${this.cardinalityMode}"\n`;
      y += `  bloom_fpr: ${this.bloomFPR}\n`;
      y += `  string_interning: true\n`;
      y += `  intern_max_value_length: 64\n`;
      if (this.queueType === 'disk') {
        y += `\nqueue:\n`;
        y += `  enabled: true\n`;
        y += `  type: disk\n`;
        y += `  path: "/var/lib/metrics-governor/queue"\n`;
        y += `  max_bytes: ${this.queueMaxSizeMB * 1048576}\n`;
        y += `  retry_interval: 5s\n`;
        y += `  max_retry_delay: 5m\n`;
      } else {
        y += `\nqueue:\n`;
        y += `  enabled: true\n`;
        y += `  type: memory\n`;
        y += `  max_bytes: ${this.queueMaxSizeMB * 1048576}\n`;
        y += `  retry_interval: 5s\n`;
        y += `  max_retry_delay: 5m\n`;
      }
      return y;
    },

    get limitsYaml() {
      let y = '';
      y += `defaults:\n`;
      y += `  max_cardinality: ${this.defaultMaxCardinality}\n`;
      y += `  max_datapoints_rate: ${this.defaultMaxDpRate}\n`;
      y += `  action: "${this.defaultAction}"\n`;
      if (this.rules.length > 0) {
        y += `\nrules:\n`;
        for (const rule of this.rules) {
          y += `  - name: "${this.escYaml(rule.name)}"\n`;
          if (rule.matchMetricName || rule.labels.length > 0) {
            y += `    match:\n`;
            if (rule.matchMetricName) {
              y += `      metric_name: "${this.escYaml(rule.matchMetricName)}"\n`;
            }
            const validLabels = rule.labels.filter(l => l.key.trim());
            if (validLabels.length > 0) {
              y += `      labels:\n`;
              for (const lbl of validLabels) {
                y += `        ${lbl.key}: "${this.escYaml(lbl.value)}"\n`;
              }
            }
          }
          if (rule.maxCardinality) y += `    max_cardinality: ${rule.maxCardinality}\n`;
          if (rule.maxDpRate) y += `    max_datapoints_rate: ${rule.maxDpRate}\n`;
          y += `    action: "${rule.action}"\n`;
          if (rule.groupBy.length > 0) {
            y += `    group_by: [${rule.groupBy.map(g => '"' + g + '"').join(', ')}]\n`;
          }
          if (rule.window) y += `    window: "${rule.window}"\n`;
        }
      } else {
        y += `\nrules: []\n`;
      }
      return y;
    },

    escYaml(s) {
      if (!s) return '';
      return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    },

    // ---- Bidirectional YAML parsing ----
    parseYamlToMap(text) {
      const map = {};
      const lines = text.split('\n');
      const indentStack = [{ indent: -1, prefix: '' }];
      for (const line of lines) {
        if (line.trim() === '' || line.trim().startsWith('#')) continue;
        const match = line.match(/^(\s*)([\w_.-]+):\s*(.*)/);
        if (!match) continue;
        const indent = match[1].length;
        const key = match[2];
        let val = match[3].trim();
        // Pop stack to find parent
        while (indentStack.length > 1 && indentStack[indentStack.length - 1].indent >= indent) {
          indentStack.pop();
        }
        const parent = indentStack[indentStack.length - 1].prefix;
        const fullKey = parent ? parent + '.' + key : key;
        if (val === '' || val === '|' || val === '>') {
          // This is a parent node
          indentStack.push({ indent, prefix: fullKey });
        } else {
          // Strip quotes
          if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
            val = val.slice(1, -1);
          }
          map[fullKey] = val;
        }
      }
      return map;
    },

    parseYamlNum(val) {
      if (val === undefined || val === null) return undefined;
      const n = Number(val);
      return isNaN(n) ? undefined : n;
    },

    parseCpuToMillicores(val) {
      if (val === undefined) return undefined;
      const s = String(val).trim();
      if (s.endsWith('m')) return parseFloat(s);
      return parseFloat(s) * 1000;
    },

    parseSizeToMB(val) {
      if (val === undefined) return undefined;
      const s = String(val).trim();
      if (s.endsWith('Mi')) return parseFloat(s);
      if (s.endsWith('Gi')) return parseFloat(s) * 1024;
      if (s.endsWith('Ti')) return parseFloat(s) * 1048576;
      // Plain number → assume bytes
      const n = parseFloat(s);
      if (!isNaN(n) && n > 1048576) return Math.ceil(n / 1048576);
      return n;
    },

    applyHelmText(text) {
      this._updatingFromYaml = true;
      try {
        const m = this.parseYamlToMap(text);
        if (m['config.bufferSize'] !== undefined) {
          const v = this.parseYamlNum(m['config.bufferSize']);
          if (v !== undefined) this.bufferMaxSize = v;
        }
        if (m['config.batchSize'] !== undefined) {
          const v = this.parseYamlNum(m['config.batchSize']);
          if (v !== undefined) this.bufferBatchSize = v;
        }
        if (m['queue.maxBytes'] !== undefined) {
          const v = this.parseYamlNum(m['queue.maxBytes']);
          if (v !== undefined) this.queueMaxSizeMB = Math.ceil(v / 1048576);
        }
        if (m['replicaCount'] !== undefined) {
          const pods = this.parseYamlNum(m['replicaCount']);
          if (pods !== undefined && pods >= 1) {
            this.podOverride = pods;
          }
        }
        if (m['resources.requests.cpu'] !== undefined) {
          const mc = this.parseCpuToMillicores(m['resources.requests.cpu']);
          if (mc !== undefined && mc > 0) {
            // reverse: perPodCpuReq = ceil(dps / pods / 100000 * 1000) → dps = mc * pods * 100
            const pods = this.actualPods;
            const newDps = Math.round(mc * pods * 100);
            if (newDps > 0) this.dps = newDps;
          }
        }
        if (m['persistence.size'] !== undefined) {
          const mb = this.parseSizeToMB(m['persistence.size']);
          if (mb !== undefined) {
            // pvcSize = queueMaxSizeMB * 1.2 → queueMaxSizeMB = pvcSize / 1.2
            this.queueMaxSizeMB = Math.max(10, Math.round(mb / 1.2));
          }
        }
      } finally {
        this.$nextTick(() => { this._updatingFromYaml = false; });
      }
    },

    applyAppText(text) {
      this._updatingFromYaml = true;
      try {
        const m = this.parseYamlToMap(text);
        if (m['buffer.size'] !== undefined) {
          const v = this.parseYamlNum(m['buffer.size']);
          if (v !== undefined) this.bufferMaxSize = v;
        }
        if (m['buffer.batch_size'] !== undefined) {
          const v = this.parseYamlNum(m['buffer.batch_size']);
          if (v !== undefined) this.bufferBatchSize = v;
        }
        if (m['performance.cardinality_mode'] !== undefined) {
          const v = m['performance.cardinality_mode'];
          if (['bloom', 'exact', 'hybrid'].includes(v)) this.cardinalityMode = v;
        }
        if (m['performance.bloom_fpr'] !== undefined) {
          const v = this.parseYamlNum(m['performance.bloom_fpr']);
          if (v !== undefined && v > 0 && v < 1) this.bloomFPR = v;
        }
        if (m['queue.type'] !== undefined) {
          const v = m['queue.type'];
          if (['memory', 'disk'].includes(v)) this.queueType = v;
        }
        if (m['queue.max_bytes'] !== undefined) {
          const v = this.parseYamlNum(m['queue.max_bytes']);
          if (v !== undefined) this.queueMaxSizeMB = Math.max(10, Math.ceil(v / 1048576));
        }
      } finally {
        this.$nextTick(() => { this._updatingFromYaml = false; });
      }
    },

    applyLimitsText(text) {
      this._updatingFromYaml = true;
      try {
        const m = this.parseYamlToMap(text);
        // Defaults
        if (m['defaults.max_cardinality'] !== undefined) {
          const v = this.parseYamlNum(m['defaults.max_cardinality']);
          if (v !== undefined) this.defaultMaxCardinality = v;
        }
        if (m['defaults.max_datapoints_rate'] !== undefined) {
          const v = this.parseYamlNum(m['defaults.max_datapoints_rate']);
          if (v !== undefined) this.defaultMaxDpRate = v;
        }
        if (m['defaults.action'] !== undefined) {
          const v = m['defaults.action'];
          if (['log', 'drop', 'adaptive'].includes(v)) this.defaultAction = v;
        }

        // Parse rules from raw text (more complex — need array handling)
        const rulesSection = text.match(/\nrules:\s*\n([\s\S]*?)(?=\n\S|\n*$)/);
        if (rulesSection) {
          const rulesText = rulesSection[1];
          const ruleBlocks = rulesText.split(/\n  - /).filter(b => b.trim());
          const newRules = [];
          for (const block of ruleBlocks) {
            const clean = block.startsWith('- ') ? block.slice(2) : block;
            const rm = this.parseYamlToMap(clean);
            const rule = {
              id: ++this.ruleIdCounter,
              name: rm['name'] || '',
              matchMetricName: rm['match.metric_name'] || '',
              labels: [],
              maxCardinality: this.parseYamlNum(rm['max_cardinality']) || 50000,
              maxDpRate: this.parseYamlNum(rm['max_datapoints_rate']) || 500000,
              action: rm['action'] || 'log',
              groupBy: [],
              customGroupBy: '',
              window: rm['window'] || '60s',
              expanded: false,
            };
            // Parse match labels
            for (const [k, v] of Object.entries(rm)) {
              if (k.startsWith('match.labels.')) {
                rule.labels.push({ key: k.replace('match.labels.', ''), value: v });
              }
            }
            // Parse group_by: [...]
            const gbMatch = clean.match(/group_by:\s*\[([^\]]*)\]/);
            if (gbMatch) {
              rule.groupBy = gbMatch[1].split(',').map(s => s.trim().replace(/^["']|["']$/g, '')).filter(Boolean);
            }
            newRules.push(rule);
          }
          this.rules = newRules;
        } else if (/rules:\s*\[\s*\]/.test(text)) {
          this.rules = [];
        }
      } finally {
        this.$nextTick(() => { this._updatingFromYaml = false; });
      }
    },

    resetYamlText(tab) {
      if (tab === 'helm') this.helmText = this.helmYaml;
      else if (tab === 'app') this.appText = this.appYaml;
      else if (tab === 'limits') this.limitsText = this.limitsYaml;
    },

    // ---- YAML validation & semantic linting ----
    validateYamlSyntax(text) {
      const issues = [];
      const lines = text.split('\n');
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim() === '' || line.trim().startsWith('#')) continue;
        if (line.includes('\t')) {
          issues.push({ type: 'error', msg: `Line ${i + 1}: Tab character found (YAML requires spaces)` });
        }
      }
      // Check balanced quotes
      let inStr = false, quoteChar = '';
      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        if (!inStr && (c === '"' || c === "'")) { inStr = true; quoteChar = c; }
        else if (inStr && c === quoteChar && text[i - 1] !== '\\') { inStr = false; }
      }
      if (inStr) issues.push({ type: 'error', msg: 'Unclosed string quote' });
      return issues;
    },

    lintHelm() {
      const issues = this.validateYamlSyntax(this.helmText);
      // Semantic checks
      if (this.actualPods < 1) issues.push({ type: 'error', msg: 'replicaCount must be >= 1' });
      if (this.perPodCpuReq <= 0) issues.push({ type: 'error', msg: 'CPU request must be > 0' });
      if (this.perPodCpuLimit < this.perPodCpuReq) issues.push({ type: 'error', msg: 'CPU limit should be >= CPU request' });
      if (this.perPodMemReq <= 0) issues.push({ type: 'error', msg: 'Memory request must be > 0' });
      if (this.perPodMemLimit < this.perPodMemReq) issues.push({ type: 'error', msg: 'Memory limit should be >= memory request' });
      if (this.bufferBatchSize > this.bufferMaxSize) issues.push({ type: 'warn', msg: 'batchSize exceeds bufferSize - batches will never fill completely' });
      if (this.queueMaxSizeMB < 10) issues.push({ type: 'warn', msg: 'Queue size < 10 MB may not provide meaningful outage buffering' });
      if (this.actualPods > 10) issues.push({ type: 'warn', msg: `High pod count (${this.actualPods}) - consider increasing cores per pod` });
      if (this.cpuUtil > 0.9) issues.push({ type: 'warn', msg: 'CPU utilization > 90% - may experience throttling under load spikes' });
      if (this.queueType === 'disk' && this.pvcSize > 10240) issues.push({ type: 'warn', msg: 'PVC size > 10 GB - verify cloud storage limits for your tier' });
      if (issues.length === 0) issues.push({ type: 'ok', msg: 'Valid - no issues found' });
      return issues;
    },

    lintApp() {
      const issues = this.validateYamlSyntax(this.appText);
      if (this.bufferMaxSize < 100) issues.push({ type: 'warn', msg: 'Buffer size < 100 may cause excessive flush cycles' });
      if (this.bufferBatchSize > this.bufferMaxSize) issues.push({ type: 'error', msg: 'batch_size exceeds buffer size' });
      if (this.bloomFPR <= 0 || this.bloomFPR >= 1) issues.push({ type: 'error', msg: 'bloom_fpr must be between 0 and 1 (exclusive)' });
      if (this.bloomFPR > 0.1) issues.push({ type: 'warn', msg: 'bloom_fpr > 0.1 may cause inaccurate cardinality tracking' });
      if (this.cardinalityMode === 'exact' && this.totalSeries > 500000) issues.push({ type: 'warn', msg: `Exact mode with ${(this.totalSeries/1000).toFixed(0)}k series uses significant memory - consider bloom or hybrid` });
      if (issues.length === 0) issues.push({ type: 'ok', msg: 'Valid - no issues found' });
      return issues;
    },

    lintLimits() {
      const issues = this.validateYamlSyntax(this.limitsText);
      if (this.defaultMaxCardinality <= 0) issues.push({ type: 'error', msg: 'defaults.max_cardinality must be > 0' });
      if (this.defaultMaxDpRate <= 0) issues.push({ type: 'error', msg: 'defaults.max_datapoints_rate must be > 0' });
      for (const rule of this.rules) {
        if (!rule.name.trim()) issues.push({ type: 'error', msg: `Rule #${this.rules.indexOf(rule) + 1}: name is required` });
        if (rule.name && /["\n\\]/.test(rule.name)) issues.push({ type: 'warn', msg: `Rule "${rule.name}": name contains special characters that may need escaping` });
        if (rule.action === 'adaptive' && rule.groupBy.length === 0) issues.push({ type: 'warn', msg: `Rule "${rule.name || '#' + (this.rules.indexOf(rule) + 1)}": adaptive action without group_by will not identify offenders` });
        if (rule.maxCardinality && rule.maxCardinality < 10) issues.push({ type: 'warn', msg: `Rule "${rule.name || '#' + (this.rules.indexOf(rule) + 1)}": max_cardinality < 10 is unusually low` });
        if (!rule.matchMetricName && rule.labels.filter(l => l.key.trim()).length === 0) issues.push({ type: 'warn', msg: `Rule "${rule.name || '#' + (this.rules.indexOf(rule) + 1)}": no match criteria - rule matches all metrics` });
        for (const lbl of rule.labels) {
          if (lbl.key.trim() && !lbl.value.trim()) issues.push({ type: 'warn', msg: `Rule "${rule.name || '#' + (this.rules.indexOf(rule) + 1)}": label "${lbl.key}" has empty value` });
        }
      }
      if (issues.length === 0) issues.push({ type: 'ok', msg: 'Valid - no issues found' });
      return issues;
    },

    get helmLint() { return this.lintHelm(); },
    get appLint() { return this.lintApp(); },
    get limitsLint() { return this.lintLimits(); },
    get helmValid() { return !this.helmLint.some(i => i.type === 'error'); },
    get appValid() { return !this.appLint.some(i => i.type === 'error'); },
    get limitsValid() { return !this.limitsLint.some(i => i.type === 'error'); },
    get helmHasWarns() { return this.helmLint.some(i => i.type === 'warn'); },
    get appHasWarns() { return this.appLint.some(i => i.type === 'warn'); },
    get limitsHasWarns() { return this.limitsLint.some(i => i.type === 'warn'); },

    // ---- Actions ----
    copyToClipboard(text, label) {
      navigator.clipboard.writeText(text).then(() => {
        this.copyOk = label;
        setTimeout(() => { this.copyOk = null; }, 2000);
      });
    },
    downloadFile(text, filename) {
      const blob = new Blob([text], { type: 'text/yaml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    },
  };
}
</script>
</body>
</html>
