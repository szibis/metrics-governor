name: Auto Release

on:
  push:
    branches: [main]

permissions:
  contents: write
  packages: write
  pull-requests: write

jobs:
  # Job 1: When a feature/fix PR is merged, create a release PR
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      release_pr_created: ${{ steps.create_pr.outputs.created }}
      version: ${{ steps.new_version.outputs.version }}
    steps:
      - name: Find merged PR
        id: find_pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          COMMIT_SHA="${{ github.sha }}"
          # Get commit message from GitHub API (no checkout yet)
          COMMIT_MSG=$(gh api "repos/${{ github.repository }}/commits/${COMMIT_SHA}" \
            --jq '.commit.message' 2>/dev/null | head -1 || echo "")

          echo "Commit SHA: ${COMMIT_SHA}"
          echo "Commit message: ${COMMIT_MSG}"

          PR_NUMBER=""
          PR_TITLE=""
          PR_LABELS=""

          # Method 1: Parse PR number from squash merge commit message "Title (#N)"
          if echo "$COMMIT_MSG" | grep -qE '\(#[0-9]+\)'; then
            PR_NUMBER=$(echo "$COMMIT_MSG" | grep -oE '#[0-9]+' | tail -1 | tr -d '#')
            echo "Found PR #${PR_NUMBER} from commit message"
          fi

          # Method 2: Fall back to commits API
          if [ -z "$PR_NUMBER" ]; then
            echo "Trying commits API fallback..."
            PR_JSON=$(gh api "repos/${{ github.repository }}/commits/${COMMIT_SHA}/pulls" \
              --jq '[.[] | select(.merged_at != null and .base.ref == "main")] | first // empty' 2>/dev/null || echo "")
            if [ -n "$PR_JSON" ]; then
              PR_NUMBER=$(echo "$PR_JSON" | jq -r '.number')
              echo "Found PR #${PR_NUMBER} from commits API"
            fi
          fi

          if [ -z "$PR_NUMBER" ]; then
            echo "No merged PR found for commit ${COMMIT_SHA}"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get full PR details using gh pr view (--repo required, no checkout yet)
          REPO="${{ github.repository }}"
          PR_TITLE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json title --jq '.title' 2>/dev/null || echo "")
          PR_LABELS=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json labels --jq '[.labels[].name] | join(",")' 2>/dev/null || echo "")

          if [ -z "$PR_TITLE" ]; then
            echo "Could not fetch PR #${PR_NUMBER} details"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found PR #${PR_NUMBER}: ${PR_TITLE}"
          echo "Labels: ${PR_LABELS}"

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "pr_labels=$PR_LABELS" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

          # Check if this is a release PR (should not trigger prepare-release)
          if echo "$PR_TITLE" | grep -q "^chore(release):"; then
            echo "This is a release PR — skipping prepare-release"
            echo "is_release_pr=true" >> $GITHUB_OUTPUT
          else
            echo "is_release_pr=false" >> $GITHUB_OUTPUT
          fi

      - uses: actions/checkout@v4
        if: steps.find_pr.outputs.skip != 'true' && steps.find_pr.outputs.is_release_pr != 'true'
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_PAT }}

      - name: Detect changes
        if: steps.find_pr.outputs.skip != 'true' && steps.find_pr.outputs.is_release_pr != 'true'
        id: detect
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get changed files from PR via GitHub API (works with squash merge)
          PR_NUMBER="${{ steps.find_pr.outputs.pr_number }}"
          CHANGED_FILES=$(gh pr view $PR_NUMBER --json files --jq '.files[].path')

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check if helm chart files changed
          if echo "$CHANGED_FILES" | grep -q "^helm/"; then
            echo "chart_changed=true" >> $GITHUB_OUTPUT
            echo "Helm chart files changed"
          else
            echo "chart_changed=false" >> $GITHUB_OUTPUT
            echo "No helm chart changes"
          fi

          # Check if app files changed (anything outside helm/, docs/, .github/)
          if echo "$CHANGED_FILES" | grep -qvE "^(helm/|docs/|\.github/|README|CHANGELOG|LICENSE)"; then
            echo "app_changed=true" >> $GITHUB_OUTPUT
            echo "App files changed"
          else
            echo "app_changed=false" >> $GITHUB_OUTPUT
            echo "No app changes"
          fi

      - name: Determine version bump
        if: steps.find_pr.outputs.skip != 'true' && steps.find_pr.outputs.is_release_pr != 'true'
        id: bump
        env:
          PR_TITLE: ${{ steps.find_pr.outputs.pr_title }}
          PR_LABELS: ${{ steps.find_pr.outputs.pr_labels }}
        run: |
          TITLE_LOWER=$(echo "$PR_TITLE" | tr '[:upper:]' '[:lower:]')

          echo "PR Title: $PR_TITLE"
          echo "Labels: $PR_LABELS"

          # Check for skip label
          if echo ",$PR_LABELS," | grep -q ",release:skip,"; then
            echo "Skipping release: release:skip label found"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for explicit version labels (highest priority)
          if echo ",$PR_LABELS," | grep -q ",release:major,"; then
            echo "bump=major" >> $GITHUB_OUTPUT
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if echo ",$PR_LABELS," | grep -q ",release:minor,"; then
            echo "bump=minor" >> $GITHUB_OUTPUT
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if echo ",$PR_LABELS," | grep -q ",release:patch,"; then
            echo "bump=patch" >> $GITHUB_OUTPUT
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for breaking change
          if echo ",$PR_LABELS," | grep -q ",breaking-change," || \
             echo "$TITLE_LOWER" | grep -qE '!:|breaking'; then
            echo "bump=major" >> $GITHUB_OUTPUT
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Determine bump from conventional commit type
          BUMP="none"
          case "$TITLE_LOWER" in
            feat:*|feat\(*) BUMP="minor" ;;
            fix:*|fix\(*) BUMP="patch" ;;
            perf:*|perf\(*) BUMP="patch" ;;
            security:*|security\(*) BUMP="patch" ;;
            deps:*|deps\(*) BUMP="patch" ;;
            ci:*|ci\(*) BUMP="patch" ;;
            build:*|build\(*) BUMP="patch" ;;
          esac

          if [ "$BUMP" = "none" ]; then
            echo "No release: PR type does not trigger release"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "bump=$BUMP" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Get current version
        if: steps.find_pr.outputs.skip != 'true' && steps.find_pr.outputs.is_release_pr != 'true' && steps.bump.outputs.skip != 'true'
        id: current
        run: |
          # Get latest version tag
          LATEST_TAG=$(git tag -l 'v*' --sort=-v:refname | head -n1)
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
          fi
          echo "Latest tag: $LATEST_TAG"
          echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT

          # Parse version components
          VERSION="${LATEST_TAG#v}"
          MAJOR=$(echo "$VERSION" | cut -d. -f1)
          MINOR=$(echo "$VERSION" | cut -d. -f2)
          PATCH=$(echo "$VERSION" | cut -d. -f3)

          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT

          # Get current chart version from Chart.yaml
          CHART_VERSION=$(grep "^version:" helm/metrics-governor/Chart.yaml | awk '{print $2}')
          echo "Current chart version: $CHART_VERSION"
          echo "chart_version=$CHART_VERSION" >> $GITHUB_OUTPUT

      - name: Calculate new version
        if: steps.find_pr.outputs.skip != 'true' && steps.find_pr.outputs.is_release_pr != 'true' && steps.bump.outputs.skip != 'true'
        id: new_version
        run: |
          BUMP="${{ steps.bump.outputs.bump }}"
          MAJOR="${{ steps.current.outputs.major }}"
          MINOR="${{ steps.current.outputs.minor }}"
          PATCH="${{ steps.current.outputs.patch }}"

          case "$BUMP" in
            major)
              NEW_MAJOR=$((MAJOR + 1))
              NEW_VERSION="v${NEW_MAJOR}.0.0"
              ;;
            minor)
              NEW_MINOR=$((MINOR + 1))
              NEW_VERSION="v${MAJOR}.${NEW_MINOR}.0"
              ;;
            patch)
              NEW_PATCH=$((PATCH + 1))
              NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"
              ;;
          esac

          echo "New version: $NEW_VERSION (bump: $BUMP)"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "version_num=${NEW_VERSION#v}" >> $GITHUB_OUTPUT

          # Calculate new chart version (only if chart changed)
          CHART_VERSION="${{ steps.current.outputs.chart_version }}"
          if [ "${{ steps.detect.outputs.chart_changed }}" == "true" ]; then
            # Bump chart patch version
            CHART_MAJOR=$(echo "$CHART_VERSION" | cut -d. -f1)
            CHART_MINOR=$(echo "$CHART_VERSION" | cut -d. -f2)
            CHART_PATCH=$(echo "$CHART_VERSION" | cut -d. -f3)
            NEW_CHART_PATCH=$((CHART_PATCH + 1))
            NEW_CHART_VERSION="${CHART_MAJOR}.${CHART_MINOR}.${NEW_CHART_PATCH}"
            echo "New chart version: $NEW_CHART_VERSION"
          else
            NEW_CHART_VERSION="$CHART_VERSION"
            echo "Chart version unchanged: $NEW_CHART_VERSION"
          fi
          echo "chart_version=$NEW_CHART_VERSION" >> $GITHUB_OUTPUT

      - name: Check if tag exists
        if: steps.find_pr.outputs.skip != 'true' && steps.find_pr.outputs.is_release_pr != 'true' && steps.bump.outputs.skip != 'true'
        id: check_tag
        run: |
          VERSION="${{ steps.new_version.outputs.version }}"
          if git rev-parse "$VERSION" >/dev/null 2>&1; then
            echo "Tag $VERSION already exists!"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog entry
        if: steps.find_pr.outputs.skip != 'true' && steps.find_pr.outputs.is_release_pr != 'true' && steps.bump.outputs.skip != 'true' && steps.check_tag.outputs.exists != 'true'
        id: changelog
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.new_version.outputs.version_num }}"
          PREV_TAG="${{ steps.current.outputs.tag }}"
          DATE=$(date +%Y-%m-%d)

          # Generate changelog from commits since last tag
          echo "## [$VERSION] - $DATE" > /tmp/changelog_entry.md
          echo "" >> /tmp/changelog_entry.md

          # Get commits since last tag
          COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"%s" --no-merges 2>/dev/null || git log HEAD~10..HEAD --pretty=format:"%s" --no-merges)

          # Categorize commits
          FEATURES=""
          FIXES=""
          PERFORMANCE=""
          OTHER=""

          while IFS= read -r commit; do
            if [[ "$commit" =~ ^feat ]]; then
              FEATURES="${FEATURES}- ${commit}\n"
            elif [[ "$commit" =~ ^fix ]]; then
              FIXES="${FIXES}- ${commit}\n"
            elif [[ "$commit" =~ ^perf ]]; then
              PERFORMANCE="${PERFORMANCE}- ${commit}\n"
            elif [[ "$commit" =~ ^(ci|build|chore|docs|test|refactor) ]]; then
              OTHER="${OTHER}- ${commit}\n"
            fi
          done <<< "$COMMITS"

          if [ -n "$FEATURES" ]; then
            echo "### Added" >> /tmp/changelog_entry.md
            echo "" >> /tmp/changelog_entry.md
            echo -e "$FEATURES" >> /tmp/changelog_entry.md
          fi

          if [ -n "$FIXES" ]; then
            echo "### Fixed" >> /tmp/changelog_entry.md
            echo "" >> /tmp/changelog_entry.md
            echo -e "$FIXES" >> /tmp/changelog_entry.md
          fi

          if [ -n "$PERFORMANCE" ]; then
            echo "### Performance" >> /tmp/changelog_entry.md
            echo "" >> /tmp/changelog_entry.md
            echo -e "$PERFORMANCE" >> /tmp/changelog_entry.md
          fi

          if [ -n "$OTHER" ]; then
            echo "### Other" >> /tmp/changelog_entry.md
            echo "" >> /tmp/changelog_entry.md
            echo -e "$OTHER" >> /tmp/changelog_entry.md
          fi

          echo "Generated changelog entry:"
          cat /tmp/changelog_entry.md

      - name: Create release branch with verified commit
        if: steps.find_pr.outputs.skip != 'true' && steps.find_pr.outputs.is_release_pr != 'true' && steps.bump.outputs.skip != 'true' && steps.check_tag.outputs.exists != 'true'
        id: create_branch
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.new_version.outputs.version }}"
          VERSION_NUM="${{ steps.new_version.outputs.version_num }}"
          CHART_VERSION="${{ steps.new_version.outputs.chart_version }}"
          BRANCH="release/${VERSION}"
          REPO="${{ github.repository }}"

          # Update Helm Chart.yaml locally
          sed -i "s/^appVersion: .*/appVersion: \"$VERSION_NUM\"/" helm/metrics-governor/Chart.yaml

          if [ "${{ steps.detect.outputs.chart_changed }}" == "true" ]; then
            sed -i "s/^version: .*/version: $CHART_VERSION/" helm/metrics-governor/Chart.yaml
            echo "Chart version bumped to $CHART_VERSION"
          fi

          # Update CHANGELOG.md locally
          {
            head -7 CHANGELOG.md
            echo ""
            cat /tmp/changelog_entry.md
            tail -n +8 CHANGELOG.md
          } > CHANGELOG.md.tmp
          mv CHANGELOG.md.tmp CHANGELOG.md

          # --- Create commit via GitHub API using GITHUB_TOKEN (auto-verified) ---
          # Commits created through the API with an installation token (GITHUB_TOKEN)
          # are automatically signed and verified by GitHub.
          BASE_SHA="${{ github.sha }}"
          BASE_TREE=$(gh api "repos/$REPO/git/commits/$BASE_SHA" --jq '.tree.sha')

          # Create blobs for modified files
          CHART_BLOB=$(jq -n --arg content "$(base64 < helm/metrics-governor/Chart.yaml)" \
            '{content: $content, encoding: "base64"}' \
            | gh api "repos/$REPO/git/blobs" --input - --jq '.sha')

          CHANGELOG_BLOB=$(jq -n --arg content "$(base64 < CHANGELOG.md)" \
            '{content: $content, encoding: "base64"}' \
            | gh api "repos/$REPO/git/blobs" --input - --jq '.sha')

          # Create tree with modified files
          TREE_SHA=$(jq -n \
            --arg base_tree "$BASE_TREE" \
            --arg chart_sha "$CHART_BLOB" \
            --arg changelog_sha "$CHANGELOG_BLOB" \
            '{
              base_tree: $base_tree,
              tree: [
                {path: "helm/metrics-governor/Chart.yaml", mode: "100644", type: "blob", sha: $chart_sha},
                {path: "CHANGELOG.md", mode: "100644", type: "blob", sha: $changelog_sha}
              ]
            }' | gh api "repos/$REPO/git/trees" --input - --jq '.sha')

          # Create commit (verified via GITHUB_TOKEN installation token)
          COMMIT_MSG="chore(release): prepare ${VERSION}

          - Update appVersion to ${VERSION_NUM}
          - Update CHANGELOG.md"

          COMMIT_SHA=$(jq -n \
            --arg message "$COMMIT_MSG" \
            --arg tree "$TREE_SHA" \
            --arg parent "$BASE_SHA" \
            '{message: $message, tree: $tree, parents: [$parent]}' \
            | gh api "repos/$REPO/git/commits" --input - --jq '.sha')

          echo "Created verified commit: $COMMIT_SHA"

          # Create branch ref pointing to the new commit
          gh api "repos/$REPO/git/refs" \
            --input <(jq -n \
              --arg ref "refs/heads/$BRANCH" \
              --arg sha "$COMMIT_SHA" \
              '{ref: $ref, sha: $sha}')

          echo "Created branch: $BRANCH"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

      - name: Create PR and enable auto-merge
        if: steps.create_branch.outputs.branch != ''
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PAT }}
        run: |
          VERSION="${{ steps.new_version.outputs.version }}"
          VERSION_NUM="${{ steps.new_version.outputs.version_num }}"
          BRANCH="${{ steps.create_branch.outputs.branch }}"

          # Create PR (using RELEASE_PAT so merge triggers workflow)
          PR_URL=$(gh pr create \
            --title "chore(release): ${VERSION}" \
            --body "## Release ${VERSION}

          This PR was automatically created to prepare release ${VERSION}.

          ### Changes
          - Updated \`appVersion\` in Chart.yaml to \`${VERSION_NUM}\`
          - Updated CHANGELOG.md with new entries

          ### After Merge
          - Tag \`${VERSION}\` will be created
          - GitHub Release will be published
          - Docker images will be pushed
          - Helm chart will be packaged

          ---
          *This PR will be auto-merged when checks pass.*" \
            --label "release:skip" \
            --base main \
            --head "$BRANCH")

          echo "Created PR: $PR_URL"
          echo "created=true" >> $GITHUB_OUTPUT
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

          # Enable auto-merge
          gh pr merge "$BRANCH" --auto --squash

      - name: Summary
        if: always()
        run: |
          echo "## Auto Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.find_pr.outputs.skip }}" == "true" ]; then
            echo "**Status:** Skipped (no merged PR found)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.find_pr.outputs.is_release_pr }}" == "true" ]; then
            echo "**Status:** Skipped (release PR merge — handled by create-release job)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.bump.outputs.skip }}" == "true" ]; then
            echo "**Status:** Skipped" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No release triggered. To force a release, add one of these labels:" >> $GITHUB_STEP_SUMMARY
            echo "- \`release:patch\` - Patch version bump" >> $GITHUB_STEP_SUMMARY
            echo "- \`release:minor\` - Minor version bump" >> $GITHUB_STEP_SUMMARY
            echo "- \`release:major\` - Major version bump" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.check_tag.outputs.exists }}" == "true" ]; then
            echo "**Status:** Skipped (tag exists)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Tag ${{ steps.new_version.outputs.version }} already exists." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.create_pr.outputs.created }}" == "true" ]; then
            echo "**Status:** Release PR Created" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| | |" >> $GITHUB_STEP_SUMMARY
            echo "|---|---|" >> $GITHUB_STEP_SUMMARY
            echo "| **Version** | ${{ steps.new_version.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Chart Version** | ${{ steps.new_version.outputs.chart_version }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Bump** | ${{ steps.bump.outputs.bump }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Previous** | ${{ steps.current.outputs.tag }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Release PR** | ${{ steps.create_pr.outputs.pr_url }} |" >> $GITHUB_STEP_SUMMARY
          fi

  # Job 2: When a release PR is merged (push to main with chore(release) commit), create tag
  create-release:
    runs-on: ubuntu-latest
    outputs:
      released: ${{ steps.release.outputs.released }}
      version: ${{ steps.release.outputs.version }}
    steps:
      - name: Find merged PR
        id: find_pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          COMMIT_SHA="${{ github.sha }}"

          # Get commit message from GitHub API (no checkout yet)
          COMMIT_MSG=$(gh api "repos/${{ github.repository }}/commits/${COMMIT_SHA}" \
            --jq '.commit.message' 2>/dev/null | head -1 || echo "")

          echo "Commit SHA: ${COMMIT_SHA}"
          echo "Commit message: ${COMMIT_MSG}"

          PR_NUMBER=""

          # Method 1: Parse PR number from squash merge commit message "Title (#N)"
          if echo "$COMMIT_MSG" | grep -qE '\(#[0-9]+\)'; then
            PR_NUMBER=$(echo "$COMMIT_MSG" | grep -oE '#[0-9]+' | tail -1 | tr -d '#')
            echo "Found PR #${PR_NUMBER} from commit message"
          fi

          # Method 2: Fall back to commits API
          if [ -z "$PR_NUMBER" ]; then
            echo "Trying commits API fallback..."
            PR_JSON=$(gh api "repos/${{ github.repository }}/commits/${COMMIT_SHA}/pulls" \
              --jq '[.[] | select(.merged_at != null and .base.ref == "main")] | first // empty' 2>/dev/null || echo "")
            if [ -n "$PR_JSON" ]; then
              PR_NUMBER=$(echo "$PR_JSON" | jq -r '.number')
              echo "Found PR #${PR_NUMBER} from commits API"
            fi
          fi

          if [ -z "$PR_NUMBER" ]; then
            echo "No merged PR found"
            echo "is_release_pr=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get PR title (--repo required, no checkout yet)
          REPO="${{ github.repository }}"
          PR_TITLE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json title --jq '.title' 2>/dev/null || echo "")
          echo "PR Title: $PR_TITLE"

          if [ -z "$PR_TITLE" ]; then
            echo "Could not fetch PR #${PR_NUMBER} details"
            echo "is_release_pr=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if echo "$PR_TITLE" | grep -q "^chore(release):"; then
            echo "is_release_pr=true" >> $GITHUB_OUTPUT
            echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
          else
            echo "is_release_pr=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract version from PR title
        if: steps.find_pr.outputs.is_release_pr == 'true'
        id: version
        env:
          PR_TITLE: ${{ steps.find_pr.outputs.pr_title }}
        run: |
          # Extract version from PR title like "chore(release): v1.2.3"
          VERSION=$(echo "$PR_TITLE" | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+')
          echo "Version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version_num=${VERSION#v}" >> $GITHUB_OUTPUT

      - name: Create tag via API
        if: steps.find_pr.outputs.is_release_pr == 'true'
        id: release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          REPO="${{ github.repository }}"
          COMMIT_SHA="${{ github.sha }}"

          # Check if tag already exists
          if gh api "repos/$REPO/git/ref/tags/$VERSION" >/dev/null 2>&1; then
            echo "Tag $VERSION already exists, skipping"
            echo "released=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create annotated tag object via API (auto-verified by GitHub)
          TAG_SHA=$(jq -n \
            --arg tag "$VERSION" \
            --arg message "Release $VERSION" \
            --arg object "$COMMIT_SHA" \
            '{tag: $tag, message: $message, object: $object, type: "commit"}' \
            | gh api "repos/$REPO/git/tags" --input - --jq '.sha')

          # Create tag ref
          gh api "repos/$REPO/git/refs" \
            --input <(jq -n \
              --arg ref "refs/tags/$VERSION" \
              --arg sha "$TAG_SHA" \
              '{ref: $ref, sha: $sha}')

          echo "Created and pushed tag: $VERSION"
          echo "released=true" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Summary
        if: steps.find_pr.outputs.is_release_pr == 'true' && steps.release.outputs.released == 'true'
        run: |
          echo "## Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Tag created and pushed. Build jobs will now run." >> $GITHUB_STEP_SUMMARY

  # Job 3: Build binaries and create GitHub release
  build-and-release:
    needs: create-release
    if: needs.create-release.outputs.released == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.create-release.outputs.version }}
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Get version
        id: version
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION_NUM=${VERSION#v}" >> $GITHUB_OUTPUT

      - name: Build binaries
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          VERSION_NUM="${{ steps.version.outputs.VERSION_NUM }}"
          LDFLAGS="-s -w -X github.com/szibis/metrics-governor/internal/config.version=${VERSION_NUM}"
          mkdir -p bin

          echo "Building version: ${VERSION_NUM}"

          GOOS=darwin GOARCH=arm64 go build -ldflags "${LDFLAGS}" -o bin/metrics-governor-darwin-arm64 ./cmd/metrics-governor
          GOOS=darwin GOARCH=amd64 go build -ldflags "${LDFLAGS}" -o bin/metrics-governor-darwin-amd64 ./cmd/metrics-governor
          GOOS=linux GOARCH=arm64 go build -ldflags "${LDFLAGS}" -o bin/metrics-governor-linux-arm64 ./cmd/metrics-governor
          GOOS=linux GOARCH=amd64 go build -ldflags "${LDFLAGS}" -o bin/metrics-governor-linux-amd64 ./cmd/metrics-governor

          cd bin
          tar -czvf metrics-governor-${VERSION}-darwin-arm64.tar.gz metrics-governor-darwin-arm64
          tar -czvf metrics-governor-${VERSION}-darwin-amd64.tar.gz metrics-governor-darwin-amd64
          tar -czvf metrics-governor-${VERSION}-linux-arm64.tar.gz metrics-governor-linux-arm64
          tar -czvf metrics-governor-${VERSION}-linux-amd64.tar.gz metrics-governor-linux-amd64
          sha256sum metrics-governor-*.tar.gz > checksums.txt

      - name: Package Helm chart
        run: |
          curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          helm package helm/metrics-governor -d bin/

      - name: Create Release and Upload Assets
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"

          echo "Creating release $VERSION..."
          gh release create "$VERSION" \
            --title "Release $VERSION" \
            --notes "See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details." \
            bin/metrics-governor-*.tar.gz bin/checksums.txt bin/metrics-governor-*.tgz

  # Job 4: Build and push Docker images
  docker:
    needs: [create-release, build-and-release]
    if: needs.create-release.outputs.released == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.create-release.outputs.version }}

      - name: Get version
        id: version
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "VERSION=${VERSION#v}" >> $GITHUB_OUTPUT

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            VERSION=${{ steps.version.outputs.VERSION }}
          tags: |
            slaskoss/metrics-governor:${{ steps.version.outputs.VERSION }}
            slaskoss/metrics-governor:latest
            ghcr.io/szibis/metrics-governor:${{ steps.version.outputs.VERSION }}
            ghcr.io/szibis/metrics-governor:latest
