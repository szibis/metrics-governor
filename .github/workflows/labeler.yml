name: PR Labeler

on:
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Get PR info
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title.toLowerCase();
            const body = (pr.body || '').toLowerCase();

            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
            });

            const changedFiles = files.map(f => f.filename);
            const additions = files.reduce((sum, f) => sum + f.additions, 0);
            const deletions = files.reduce((sum, f) => sum + f.deletions, 0);
            const totalChanges = additions + deletions;

            const labels = new Set();

            // === Type labels based on PR title (conventional commits) ===
            if (title.startsWith('fix:') || title.startsWith('fix(')) {
              labels.add('bug');
            }
            if (title.startsWith('feat:') || title.startsWith('feat(')) {
              labels.add('enhancement');
            }
            if (title.startsWith('docs:') || title.startsWith('docs(')) {
              labels.add('documentation');
            }
            if (title.startsWith('perf:') || title.startsWith('perf(')) {
              labels.add('performance');
            }
            if (title.startsWith('refactor:') || title.startsWith('refactor(')) {
              labels.add('refactor');
            }
            if (title.startsWith('test:') || title.startsWith('test(')) {
              labels.add('testing');
            }
            if (title.startsWith('ci:') || title.startsWith('ci(')) {
              labels.add('ci');
            }
            if (title.startsWith('chore:') || title.startsWith('chore(')) {
              labels.add('chore');
            }
            if (title.startsWith('build:') || title.startsWith('build(')) {
              labels.add('build');
            }
            if (title.startsWith('release:') || title.includes('release')) {
              labels.add('release');
            }

            // === Component labels based on changed files ===
            const componentPatterns = {
              'component/buffer': /^internal\/buffer\//,
              'component/queue': /^internal\/queue\//,
              'component/exporter': /^internal\/exporter\//,
              'component/receiver': /^internal\/receiver\//,
              'component/config': /^internal\/config\//,
              'component/compression': /^internal\/compression\//,
              'component/auth': /^internal\/auth\//,
              'component/limits': /^internal\/limits\//,
              'component/stats': /^internal\/stats\//,
              'component/sharding': /^internal\/sharding\//,
              'component/prw': /^internal\/prw\//,
              'component/tls': /^internal\/tls\//,
              'helm': /^helm\//,
              'ci': /^\.github\//,
              'documentation': /\.(md|MD)$|^docs\//,
            };

            for (const file of changedFiles) {
              for (const [label, pattern] of Object.entries(componentPatterns)) {
                if (pattern.test(file)) {
                  labels.add(label);
                }
              }
            }

            // === Size labels based on total changes ===
            if (totalChanges <= 10) {
              labels.add('size/XS');
            } else if (totalChanges <= 50) {
              labels.add('size/S');
            } else if (totalChanges <= 200) {
              labels.add('size/M');
            } else if (totalChanges <= 500) {
              labels.add('size/L');
            } else {
              labels.add('size/XL');
            }

            // === Special labels ===
            if (title.includes('breaking') || body.includes('breaking change')) {
              labels.add('breaking-change');
            }
            if (title.includes('wip') || title.includes('draft') || pr.draft) {
              labels.add('work-in-progress');
            }
            if (changedFiles.some(f => f.includes('_test.go'))) {
              labels.add('testing');
            }
            if (changedFiles.some(f => f.includes('benchmark'))) {
              labels.add('performance');
            }

            core.setOutput('labels', Array.from(labels).join(','));
            console.log('Labels to add:', Array.from(labels));

      - name: Add labels
        uses: actions/github-script@v7
        with:
          script: |
            const labelsStr = '${{ steps.pr.outputs.labels }}';
            if (!labelsStr) {
              console.log('No labels to add');
              return;
            }

            const labels = labelsStr.split(',').filter(l => l.trim());
            if (labels.length === 0) {
              console.log('No labels to add');
              return;
            }

            // Get existing labels
            const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
            });

            const existingLabelNames = existingLabels.map(l => l.name);

            // Filter out size labels if one already exists (to avoid multiple size labels)
            const sizeLabels = ['size/XS', 'size/S', 'size/M', 'size/L', 'size/XL'];
            const hasExistingSize = existingLabelNames.some(l => sizeLabels.includes(l));

            let labelsToAdd = labels;
            if (hasExistingSize) {
              // Remove size labels from new labels if PR already has a size label
              labelsToAdd = labels.filter(l => !sizeLabels.includes(l));
            }

            // Only add labels that don't already exist
            const newLabels = labelsToAdd.filter(l => !existingLabelNames.includes(l));

            if (newLabels.length === 0) {
              console.log('All labels already exist');
              return;
            }

            console.log('Adding labels:', newLabels);

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: newLabels,
            });
