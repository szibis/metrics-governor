name: Build

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  pull-requests: write

jobs:
  ci-filter:
    uses: ./.github/workflows/ci-filter.yml

  build:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      next_release: ${{ steps.next_release.outputs.version }}
      release_bump: ${{ steps.next_release.outputs.bump }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Determine current version
        id: version
        run: |
          # Get version from git describe or Chart.yaml
          if git describe --tags --exact-match 2>/dev/null; then
            VERSION=$(git describe --tags --exact-match)
          else
            # For PRs/branches, use Chart.yaml version + short SHA
            CHART_VERSION=$(grep '^version:' helm/metrics-governor/Chart.yaml | awk '{print $2}')
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="${CHART_VERSION}-${SHORT_SHA}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Building version: ${VERSION}"

      - name: Calculate next release version
        id: next_release
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title.toLowerCase();
            const labels = pr.labels.map(l => l.name);

            console.log('PR Title:', pr.title);
            console.log('Labels:', labels);

            // Get latest version tag
            const { execSync } = require('child_process');
            let latestTag = 'v0.0.0';
            try {
              latestTag = execSync("git tag -l 'v*' --sort=-v:refname | head -n1", { encoding: 'utf8' }).trim();
              if (!latestTag) latestTag = 'v0.0.0';
            } catch (e) {
              console.log('No tags found, using v0.0.0');
            }

            console.log('Latest tag:', latestTag);

            // Parse version
            const versionMatch = latestTag.match(/v(\d+)\.(\d+)\.(\d+)/);
            let major = 0, minor = 0, patch = 0;
            if (versionMatch) {
              major = parseInt(versionMatch[1]);
              minor = parseInt(versionMatch[2]);
              patch = parseInt(versionMatch[3]);
            }

            // Determine bump type
            let bump = 'none';

            // Check for skip label
            if (labels.includes('release:skip')) {
              bump = 'skip';
            }
            // Check for explicit version labels (highest priority)
            else if (labels.includes('release:major')) {
              bump = 'major';
            } else if (labels.includes('release:minor')) {
              bump = 'minor';
            } else if (labels.includes('release:patch')) {
              bump = 'patch';
            }
            // Check for breaking change
            else if (labels.includes('breaking-change') || title.includes('!:') || title.includes('breaking')) {
              bump = 'major';
            }
            // Determine from conventional commit type
            else {
              const conventionalTypes = {
                'feat': 'minor',
                'fix': 'patch',
                'perf': 'patch',
                'security': 'patch',
                'deps': 'patch',
                'ci': 'patch',
                'build': 'patch',
              };

              for (const [type, bumpType] of Object.entries(conventionalTypes)) {
                if (title.startsWith(`${type}:`) || title.startsWith(`${type}(`)) {
                  bump = bumpType;
                  break;
                }
              }
            }

            // Calculate new version
            let newVersion = 'no release';
            if (bump === 'major') {
              newVersion = `v${major + 1}.0.0`;
            } else if (bump === 'minor') {
              newVersion = `v${major}.${minor + 1}.0`;
            } else if (bump === 'patch') {
              newVersion = `v${major}.${minor}.${patch + 1}`;
            } else if (bump === 'skip') {
              newVersion = 'skipped';
            }

            console.log(`Bump: ${bump}, New version: ${newVersion}`);

            core.setOutput('version', newVersion);
            core.setOutput('bump', bump);
            core.setOutput('current', latestTag);

      - name: Build
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          go build -ldflags "-X github.com/szibis/metrics-governor/internal/config.version=${VERSION}" -v ./...

      - name: Version summary
        if: github.event_name == 'pull_request'
        run: |
          echo "## ðŸ“¦ Version Info" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| | |" >> $GITHUB_STEP_SUMMARY
          echo "|---|---|" >> $GITHUB_STEP_SUMMARY
          echo "| **Build Version** | \`${{ steps.version.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Next Release** | \`${{ steps.next_release.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Bump Type** | ${{ steps.next_release.outputs.bump }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Current Tag** | ${{ steps.next_release.outputs.current }} |" >> $GITHUB_STEP_SUMMARY

  test-unit:
    needs: [ci-filter]
    runs-on: ubuntu-latest
    if: >-
      needs.ci-filter.outputs.skip_tests != 'true' &&
      !(
        github.event_name == 'pull_request' &&
        contains(github.event.pull_request.labels.*.name, 'release:skip')
      )
    outputs:
      coverage: ${{ steps.coverage.outputs.coverage }}
      total_tests: ${{ steps.count.outputs.total }}
      passed_tests: ${{ steps.count.outputs.passed }}
      success: ${{ steps.count.outputs.success }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Run unit tests with coverage
        id: unit_tests
        continue-on-error: true
        run: |
          go test -v -race -coverprofile=coverage-unit.out -covermode=atomic ./internal/... 2>&1 | tee unit-test-output.txt

      - name: Extract coverage percentage
        id: coverage
        run: |
          COVERAGE=$(go tool cover -func=coverage-unit.out | grep total | awk '{print $3}' | sed 's/%//')
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
          echo "Unit test coverage: $COVERAGE%"

      - name: Check coverage threshold
        run: |
          COVERAGE="${{ steps.coverage.outputs.coverage }}"
          THRESHOLD=85
          echo "Coverage: $COVERAGE%"
          echo "Required threshold: $THRESHOLD%"
          if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
            echo "âŒ Coverage $COVERAGE% is below the required threshold of $THRESHOLD%"
            exit 1
          else
            echo "âœ… Coverage $COVERAGE% meets the required threshold of $THRESHOLD%"
          fi

      - name: Count tests
        id: count
        if: always()
        run: |
          # Count test results from package summaries
          # Note: grep -c returns exit code 1 when no matches, so we handle it separately
          if [ -f unit-test-output.txt ]; then
            PASSED_PKGS=$(grep -c '^ok' unit-test-output.txt) || PASSED_PKGS=0
            FAILED_PKGS=$(grep -c '^FAIL' unit-test-output.txt) || FAILED_PKGS=0
          else
            echo "Warning: unit-test-output.txt not found"
            PASSED_PKGS=0
            FAILED_PKGS=0
          fi
          # Determine success based on whether any packages failed
          # Also check the test step outcome
          TEST_OUTCOME="${{ steps.unit_tests.outcome }}"
          if [ "$TEST_OUTCOME" = "success" ] && [ "$FAILED_PKGS" = "0" ] && [ "$PASSED_PKGS" -gt "0" ]; then
            SUCCESS="true"
          else
            SUCCESS="false"
          fi
          echo "total=$PASSED_PKGS" >> $GITHUB_OUTPUT
          echo "passed=$PASSED_PKGS" >> $GITHUB_OUTPUT
          echo "failed=$FAILED_PKGS" >> $GITHUB_OUTPUT
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "Test results: $PASSED_PKGS packages passed, $FAILED_PKGS failed (test outcome: $TEST_OUTCOME)"

      - name: Upload coverage artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-unit
          path: |
            coverage-unit.out
            unit-test-output.txt
          retention-days: 7

  test-functional:
    needs: [ci-filter]
    runs-on: ubuntu-latest
    if: >-
      needs.ci-filter.outputs.skip_tests != 'true' &&
      !(
        github.event_name == 'pull_request' &&
        contains(github.event.pull_request.labels.*.name, 'release:skip')
      )
    outputs:
      total_tests: ${{ steps.count.outputs.total }}
      passed_tests: ${{ steps.count.outputs.passed }}
      success: ${{ steps.count.outputs.success }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Run functional tests
        id: functional_tests
        continue-on-error: true
        run: |
          go test -v -race ./functional/... 2>&1 | tee functional-test-output.txt

      - name: Count tests
        id: count
        if: always()
        run: |
          if [ -f functional-test-output.txt ]; then
            PASSED_PKGS=$(grep -c '^ok' functional-test-output.txt) || PASSED_PKGS=0
            FAILED_PKGS=$(grep -c '^FAIL' functional-test-output.txt) || FAILED_PKGS=0
          else
            echo "Warning: functional-test-output.txt not found"
            PASSED_PKGS=0
            FAILED_PKGS=0
          fi
          TEST_OUTCOME="${{ steps.functional_tests.outcome }}"
          if [ "$TEST_OUTCOME" = "success" ] && [ "$FAILED_PKGS" = "0" ] && [ "$PASSED_PKGS" -gt "0" ]; then
            SUCCESS="true"
          else
            SUCCESS="false"
          fi
          echo "total=$PASSED_PKGS" >> $GITHUB_OUTPUT
          echo "passed=$PASSED_PKGS" >> $GITHUB_OUTPUT
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "Test results: $PASSED_PKGS packages passed, $FAILED_PKGS failed (test outcome: $TEST_OUTCOME)"

  test-e2e:
    needs: [ci-filter]
    runs-on: ubuntu-latest
    if: >-
      needs.ci-filter.outputs.skip_tests != 'true' &&
      !(
        github.event_name == 'pull_request' &&
        contains(github.event.pull_request.labels.*.name, 'release:skip')
      )
    outputs:
      total_tests: ${{ steps.count.outputs.total }}
      passed_tests: ${{ steps.count.outputs.passed }}
      success: ${{ steps.count.outputs.success }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Run e2e tests
        id: e2e_tests
        continue-on-error: true
        run: |
          go test -v -race ./e2e/... 2>&1 | tee e2e-test-output.txt

      - name: Count tests
        id: count
        if: always()
        run: |
          if [ -f e2e-test-output.txt ]; then
            echo "=== E2E test output ==="
            cat e2e-test-output.txt | tail -20
            echo "======================="
            PASSED_PKGS=$(grep -c '^ok' e2e-test-output.txt) || PASSED_PKGS=0
            FAILED_PKGS=$(grep -c '^FAIL' e2e-test-output.txt) || FAILED_PKGS=0
          else
            echo "Warning: e2e-test-output.txt not found"
            PASSED_PKGS=0
            FAILED_PKGS=0
          fi
          TEST_OUTCOME="${{ steps.e2e_tests.outcome }}"
          if [ "$TEST_OUTCOME" = "success" ] && [ "$FAILED_PKGS" = "0" ] && [ "$PASSED_PKGS" -gt "0" ]; then
            SUCCESS="true"
          else
            SUCCESS="false"
          fi
          echo "total=$PASSED_PKGS" >> $GITHUB_OUTPUT
          echo "passed=$PASSED_PKGS" >> $GITHUB_OUTPUT
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "Test results: $PASSED_PKGS packages passed, $FAILED_PKGS failed (test outcome: $TEST_OUTCOME)"

  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Install golangci-lint
        run: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

      - name: Run golangci-lint
        run: golangci-lint run --timeout=5m

  lint-dockerfile:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install hadolint
        run: |
          wget -qO- https://github.com/hadolint/hadolint/releases/download/v2.12.0/hadolint-Linux-x86_64 > hadolint
          chmod +x hadolint
          sudo mv hadolint /usr/local/bin/

      - name: Lint Dockerfile
        run: hadolint Dockerfile --failure-threshold warning

      - name: Lint test Dockerfile
        run: hadolint test/Dockerfile.generator --failure-threshold warning

  lint-yaml:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install yamllint
        run: pip install yamllint

      - name: Lint YAML config examples
        run: yamllint -c .yamllint.yml examples/

      - name: Lint Helm values
        run: yamllint -c .yamllint.yml helm/metrics-governor/values.yaml

      - name: Lint Helm Chart.yaml
        run: yamllint -c .yamllint.yml helm/metrics-governor/Chart.yaml

  lint-helm:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Lint Helm chart
        run: helm lint helm/metrics-governor

  test-helm:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Install helm-unittest
        run: helm plugin install https://github.com/helm-unittest/helm-unittest

      - name: Run Helm chart unit tests
        run: helm unittest helm/metrics-governor

  validate-config-helper:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Validate config helper against Go defaults
        run: go test -v ./tools/config-helper/...

      - name: Check config-meta is up to date
        run: |
          go run ./tools/config-helper/cmd/generate
          if ! git diff --quiet tools/config-helper/index.html index.html; then
            echo "::error::config-meta JSON is out of date. Run 'make generate-config-meta' and commit."
            git diff --stat
            exit 1
          fi

  # Post test coverage comment on PR
  coverage-comment:
    needs: [ci-filter, build, test-unit, test-functional, test-e2e, test-e2e-docker]
    runs-on: ubuntu-latest
    if: >-
      always() &&
      needs.ci-filter.outputs.skip_tests != 'true' &&
      github.event_name == 'pull_request' &&
      !contains(github.event.pull_request.labels.*.name, 'release:skip')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Download coverage artifact
        uses: actions/download-artifact@v7
        with:
          name: coverage-unit
          path: ./coverage

      - name: Get base branch coverage
        id: base_coverage
        run: |
          # Store current branch/commit
          CURRENT_REF="${{ github.event.pull_request.head.sha }}"
          echo "Current ref: $CURRENT_REF"

          # Fetch base branch
          git fetch origin ${{ github.event.pull_request.base.ref }} --depth=1

          # Checkout base branch (detached HEAD is fine)
          git checkout ${{ github.event.pull_request.base.sha }} || git checkout origin/${{ github.event.pull_request.base.ref }}

          # Run coverage on base
          go test -coverprofile=coverage-base.out -covermode=atomic ./internal/... 2>/dev/null || true

          if [ -f coverage-base.out ]; then
            BASE_COV=$(go tool cover -func=coverage-base.out | grep total | awk '{print $3}' | sed 's/%//')
            echo "coverage=$BASE_COV" >> $GITHUB_OUTPUT
            echo "Base coverage: $BASE_COV%"
          else
            echo "coverage=0" >> $GITHUB_OUTPUT
            echo "No base coverage file generated"
          fi

          # Switch back to PR branch
          git checkout $CURRENT_REF || git checkout -

      - name: Generate coverage report
        id: report
        run: |
          # Get values with defaults for empty outputs
          UNIT_COVERAGE="${{ needs.test-unit.outputs.coverage }}"
          UNIT_COVERAGE="${UNIT_COVERAGE:-0}"
          BASE_COVERAGE="${{ steps.base_coverage.outputs.coverage }}"
          BASE_COVERAGE="${BASE_COVERAGE:-0}"

          # Get test counts with defaults
          UNIT_TOTAL="${{ needs.test-unit.outputs.total_tests }}"
          UNIT_TOTAL="${UNIT_TOTAL:-0}"
          UNIT_PASSED="${{ needs.test-unit.outputs.passed_tests }}"
          UNIT_PASSED="${UNIT_PASSED:-0}"
          UNIT_SUCCESS="${{ needs.test-unit.outputs.success }}"
          UNIT_SUCCESS="${UNIT_SUCCESS:-false}"

          FUNC_TOTAL="${{ needs.test-functional.outputs.total_tests }}"
          FUNC_TOTAL="${FUNC_TOTAL:-0}"
          FUNC_PASSED="${{ needs.test-functional.outputs.passed_tests }}"
          FUNC_PASSED="${FUNC_PASSED:-0}"
          FUNC_SUCCESS="${{ needs.test-functional.outputs.success }}"
          FUNC_SUCCESS="${FUNC_SUCCESS:-false}"

          E2E_TOTAL="${{ needs.test-e2e.outputs.total_tests }}"
          E2E_TOTAL="${E2E_TOTAL:-0}"
          E2E_PASSED="${{ needs.test-e2e.outputs.passed_tests }}"
          E2E_PASSED="${E2E_PASSED:-0}"
          E2E_SUCCESS="${{ needs.test-e2e.outputs.success }}"
          E2E_SUCCESS="${E2E_SUCCESS:-false}"

          E2E_DOCKER_SUCCESS="${{ needs.test-e2e-docker.outputs.success }}"
          E2E_DOCKER_SUCCESS="${E2E_DOCKER_SUCCESS:-false}"

          echo "=== Coverage Report Debug ==="
          echo "Unit coverage: $UNIT_COVERAGE%"
          echo "Base coverage: $BASE_COVERAGE%"
          echo "Unit tests: $UNIT_PASSED packages (success=$UNIT_SUCCESS)"
          echo "Functional tests: $FUNC_PASSED packages (success=$FUNC_SUCCESS)"
          echo "E2E tests: $E2E_PASSED packages (success=$E2E_SUCCESS)"
          echo "Docker E2E: success=$E2E_DOCKER_SUCCESS"
          echo "=============================="

          TOTAL_TESTS=$((UNIT_TOTAL + FUNC_TOTAL + E2E_TOTAL))
          TOTAL_PASSED=$((UNIT_PASSED + FUNC_PASSED + E2E_PASSED))

          # Determine overall success
          if [ "$UNIT_SUCCESS" = "true" ] && [ "$FUNC_SUCCESS" = "true" ] && [ "$E2E_SUCCESS" = "true" ] && [ "$E2E_DOCKER_SUCCESS" = "true" ]; then
            ALL_SUCCESS="true"
          else
            ALL_SUCCESS="false"
          fi

          # Calculate coverage delta
          if [ -n "$BASE_COVERAGE" ] && [ "$BASE_COVERAGE" != "0" ]; then
            DELTA=$(echo "$UNIT_COVERAGE - $BASE_COVERAGE" | bc)
            if (( $(echo "$DELTA > 0" | bc -l) )); then
              DELTA_ICON="ðŸ“ˆ"
              DELTA_STR="+${DELTA}%"
            elif (( $(echo "$DELTA < 0" | bc -l) )); then
              DELTA_ICON="ðŸ“‰"
              DELTA_STR="${DELTA}%"
            else
              DELTA_ICON="âž¡ï¸"
              DELTA_STR="Â±0%"
            fi
          else
            DELTA_ICON="ðŸ†•"
            DELTA_STR="N/A"
          fi

          # Determine coverage badge color and threshold status (85% required)
          THRESHOLD=85
          if (( $(echo "$UNIT_COVERAGE >= $THRESHOLD" | bc -l) )); then
            COV_STATUS="ðŸŸ¢"
            THRESHOLD_STATUS="âœ… Passed"
          elif (( $(echo "$UNIT_COVERAGE >= 80" | bc -l) )); then
            COV_STATUS="ðŸŸ¡"
            THRESHOLD_STATUS="âš ï¸ Below ${THRESHOLD}%"
          else
            COV_STATUS="ðŸ”´"
            THRESHOLD_STATUS="âŒ Below ${THRESHOLD}%"
          fi

          # Get version from build job
          BUILD_VERSION="${{ needs.build.outputs.version }}"
          NEXT_RELEASE="${{ needs.build.outputs.next_release }}"
          RELEASE_BUMP="${{ needs.build.outputs.release_bump }}"

          # Determine release badge
          case "$RELEASE_BUMP" in
            major) RELEASE_BADGE="ðŸ”´ Major" ;;
            minor) RELEASE_BADGE="ðŸŸ¡ Minor" ;;
            patch) RELEASE_BADGE="ðŸŸ¢ Patch" ;;
            skip)  RELEASE_BADGE="â­ï¸ Skip" ;;
            *)     RELEASE_BADGE="âšª None" ;;
          esac

          # Create comment
          cat > coverage-comment.md << EOF
          ## ðŸ“Š Test Coverage Report

          | Build | Release |
          |-------|---------|
          | \`${BUILD_VERSION}\` | **${NEXT_RELEASE}** (${RELEASE_BADGE}) |

          | Metric | Value | Status |
          |--------|-------|--------|
          | **Code Coverage** | ${UNIT_COVERAGE}% | ${COV_STATUS} |
          | **Required Threshold** | ${THRESHOLD}% | ${THRESHOLD_STATUS} |
          | **Coverage Change** | ${DELTA_STR} | ${DELTA_ICON} |
          | **Base Coverage** | ${BASE_COVERAGE}% | - |

          ### Test Results

          | Suite | Packages | Status |
          |-------|----------|--------|
          | Unit Tests | ${UNIT_TOTAL} | $( [ "$UNIT_SUCCESS" = "true" ] && echo "âœ… Passed" || echo "âŒ Failed" ) |
          | Functional Tests | ${FUNC_TOTAL} | $( [ "$FUNC_SUCCESS" = "true" ] && echo "âœ… Passed" || echo "âŒ Failed" ) |
          | E2E Tests | ${E2E_TOTAL} | $( [ "$E2E_SUCCESS" = "true" ] && echo "âœ… Passed" || echo "âŒ Failed" ) |
          | Docker E2E | - | $( [ "$E2E_DOCKER_SUCCESS" = "true" ] && echo "âœ… Passed" || echo "âŒ Failed" ) |
          | **Total** | **${TOTAL_TESTS}** | $( [ "$ALL_SUCCESS" = "true" ] && echo "âœ… **All Passed**" || echo "âŒ **Some Failed**" ) |

          <details>
          <summary>Coverage Thresholds</summary>

          - ðŸŸ¢ **Good**: >= 90%
          - ðŸŸ¡ **Warning**: 80-89%
          - ðŸ”´ **Critical**: < 80%

          </details>

          ---
          *See [Benchmark Comparison](#benchmark-comparison) comment for performance results.*
          EOF

          cat coverage-comment.md

      - name: Post coverage comment
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            let comment = fs.readFileSync('coverage-comment.md', 'utf8');

            // Add timestamp to track updates
            const timestamp = new Date().toISOString();
            comment += `\n\n_Last updated: ${timestamp}_`;

            // Find existing coverage comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              (c.user.login === 'github-actions[bot]' || c.user.login === 'github-actions') &&
              c.body.includes('Test Coverage Report')
            );

            if (botComment) {
              console.log(`Updating existing comment ${botComment.id}`);
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              console.log('Creating new coverage comment');
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }

  # Docker Compose E2E test - full stack verification
  test-e2e-docker:
    needs: [ci-filter, build]
    runs-on: ubuntu-latest
    if: >-
      needs.ci-filter.outputs.skip_tests != 'true' &&
      !(
        github.event_name == 'pull_request' &&
        contains(github.event.pull_request.labels.*.name, 'release:skip')
      )
    outputs:
      success: ${{ steps.result.outputs.success }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Run Docker Compose E2E tests
        id: e2e_docker
        timeout-minutes: 15
        env:
          BUILD_VERSION: ${{ needs.build.outputs.version }}
        run: |
          echo "ðŸ“¦ Testing version: ${BUILD_VERSION}"
          chmod +x test/e2e-docker-compose.sh
          ./test/e2e-docker-compose.sh 2>&1 | tee e2e-docker-output.txt

      - name: Set result
        id: result
        if: always()
        run: |
          if [ "${{ steps.e2e_docker.outcome }}" = "success" ]; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-docker-logs
          path: |
            e2e-docker-output.txt
          retention-days: 7

      - name: Cleanup
        if: always()
        run: docker compose down -v --remove-orphans 2>/dev/null || true

  build-binaries:
    needs: [ci-filter, build, test-unit, test-functional, test-e2e, test-e2e-docker, lint, lint-dockerfile, lint-yaml, lint-helm, test-helm]
    runs-on: ubuntu-latest
    if: >-
      needs.ci-filter.outputs.skip_tests != 'true' &&
      !(
        github.event_name == 'pull_request' &&
        contains(github.event.pull_request.labels.*.name, 'release:skip')
      )
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Get version
        id: version
        run: |
          VERSION="${{ needs.build.outputs.version }}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Building binaries for version: ${VERSION}"

      - name: Build darwin-arm64
        run: |
          LDFLAGS="-s -w -X github.com/szibis/metrics-governor/internal/config.version=${{ steps.version.outputs.version }}"
          GOOS=darwin GOARCH=arm64 go build -ldflags "${LDFLAGS}" -o bin/metrics-governor-darwin-arm64 ./cmd/metrics-governor

      - name: Build linux-arm64
        run: |
          LDFLAGS="-s -w -X github.com/szibis/metrics-governor/internal/config.version=${{ steps.version.outputs.version }}"
          GOOS=linux GOARCH=arm64 go build -ldflags "${LDFLAGS}" -o bin/metrics-governor-linux-arm64 ./cmd/metrics-governor

      - name: Build linux-amd64
        run: |
          LDFLAGS="-s -w -X github.com/szibis/metrics-governor/internal/config.version=${{ steps.version.outputs.version }}"
          GOOS=linux GOARCH=amd64 go build -ldflags "${LDFLAGS}" -o bin/metrics-governor-linux-amd64 ./cmd/metrics-governor

      - name: Verify version
        run: |
          echo "Verifying embedded version..."
          ./bin/metrics-governor-linux-amd64 -version

      - name: Upload binaries
        uses: actions/upload-artifact@v4
        with:
          name: binaries
          path: bin/
          retention-days: 7
